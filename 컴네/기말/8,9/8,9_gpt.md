바로 네! 😊
네트워크 계층 8, 9 pdf 내용 전체를 “슬라이드 읽는 느낌”이 아니라 “강의 듣는 느낌”으로 처음부터 끝까지 풀어볼게.
(설명은 자연스럽게 풀어서 하지만, 슬라이드에 나온 개념은 하나도 빼지 않고 다 언급할 거야.)

---

## 1. 네트워크 계층가 뭐 하는 층인지부터

네트워크 계층(Network layer)은 “**IP 패킷이 출발지 호스트에서 목적지 호스트까지 가는 길을 책임지는 층**이야.

* 송신 측(host): 전송계층(TCP/UDP)에서 세그먼트를 받아서, 여기에 **IP 헤더를 붙여 데이터그램(datagram)**을 만들고 링크 계층으로 내려보내.
* 수신 측(host): 링크 계층에서 온 프레임에서 **IP 데이터그램을 꺼내 전송계층**에 넘겨줘.

이때 네트워크 계층 프로토콜(IP, ICMP, 라우팅 프로토콜 등)은

* **호스트**에도 있고
* **라우터**에도 있어.

### 라우터가 하는 일

라우터는 “길잡이” 역할을 해.

1. 지나가는 모든 **IP 데이터그램의 헤더를 확인**하고
2. “이 패킷은 어느 출력 포트로 보내야 하지?”를 결정해서
3. 여러 라우터를 거쳐 **end-to-end 경로**를 따라 패킷을 옮겨줘.

---

## 2. 포워딩 vs 라우팅 / 데이터 평면 vs 제어 평면

이 둘의 구분을 완전히 잡고 가면 뒤가 다 정리돼.

### 포워딩(Forwarding)

* **“한 라우터 안에서”** 일어나는 일
* 입력 포트로 들어온 패킷을, **포워딩 테이블을 보고 어느 출력 포트로 보낼지** 결정해서 옮기는 동작
  → 아주 빠르게, 하드웨어 수준에서 수행됨.

### 라우팅(Routing)

* **“네트워크 전체 관점에서”** 출발지→목적지 전체 경로(path)를 정하는 것.
* 라우팅 알고리즘(RIP, OSPF, BGP 등)이 전체 토폴로지/비용 정보를 이용해서 경로를 계산해 줘.

### 데이터 평면(Data Plane)

* **각 라우터 내부**에서 돌아가는 로컬 기능
* 들어온 패킷 헤더를 보고, 이미 만들어진 포워딩 테이블을 사용해서 “어디로 보낼지” 즉시 결정
* 하드웨어 기반 → **아주 빠름(나노초급)**

### 제어 평면(Control Plane)

* **네트워크 전체**에서 경로를 결정하고, 그 결과로 **포워딩 테이블을 구성/갱신**하는 역할
* 라우팅 알고리즘, SDN 컨트롤러 등
* 소프트웨어 기반 → **상대적으로 느림(밀리초)**

제어 평면 구현 방식은 두 가지:

1. **Per-router Control (전통형)**

   * 각 라우터가 자기 안에서 라우팅 알고리즘을 실행하고
   * 이웃 라우터들과 라우팅 메시지를 주고받으며 테이블을 채움. (RIP, OSPF 등)
2. **Logically Centralized Control (SDN 스타일)**

   * 중앙 **SDN 컨트롤러**가 전체 네트워크 상태를 보고 경로를 계산하고,
   * 각 스위치/라우터에게 “포워딩 규칙”을 내려줌.
   * 장점: 관리 쉬움, 정책 반영 및 변경 용이, 전체 최적화 가능.

---

## 3. 네트워크 계층 서비스 모델 (Best-effort, QoS 등)

네트워크 계층이 애플리케이션에게 어떤 “서비스 모델”로 통신을 제공하느냐의 관점이야.

### 데이터그램 단위 서비스 예시

* 보장된 전송 (Guaranteed delivery)
* 지연이 특정 값보다 작도록 보장 (예: delay < 40ms)

### 흐름(Flow) 단위 서비스 예시

* 순서 보장(In-order delivery)
* 최소 대역폭 보장(Minimum bandwidth)
* 패킷 간 간격 변화 제한(Inter-packet spacing constraints)

이런 건 과거에 ATM 같은 네트워크에서 지향하던 **“보장형 서비스”**에 가까워.

### 인터넷(IPv4)의 현실: Best-effort

인터넷의 IP는 **Best-effort** 모델이야.

* **보장 X**:

  * 패킷이 반드시 도착하는지 보장 안 함
  * 도착 순서, 도착 시간도 보장 안 함
  * 특정 대역폭도 보장 안 함

그런데도 왜 성공했냐?

* 구조가 엄청 단순해서 구현이 쉽고, 전 세계 어디서나 쓸 수 있음.
* 오늘날은 **대역폭이 크게 늘고**, 데이터센터·CDN이 사용자 가까운 곳에서 제공되기 때문에
  “Best-effort인데도 대체로 충분히 잘 돌아감”.
* 전송계층의 **혼잡제어(TCP)**가 전체 품질을 어느 정도 유지해 줌.

---

## 4. 라우터 내부 구조 (Data Plane 쪽)

라우터를 속까지 뜯어보자.

### 라우터의 구성 요소

* 입력 포트(Input ports)
* 출력 포트(Output ports)
* 스위칭 패브릭(Switching fabric)
* 버퍼(Buffer) + 스케줄러(Scheduler)

역할은 단순해:

> 입력 포트에서 데이터그램을 받고 → 처리하고 → 스위칭 패브릭을 통해 → 출력 포트로 전달

### 입력 포트가 하는 일

1. **라인 종단(Line termination)**

   * 물리계층 신호(전기/광)를 비트로 복원
2. **링크 계층 프로토콜 처리** (Ethernet 등)
3. **포워딩 테이블 조회(Lookup)**

   * 목 IP를 보고 어떤 출력 포트로 갈지 결정
4. **입력 큐잉(Input queuing)**

   * 들어오는 속도가 너무 빠르면 일단 버퍼(큐)에 넣어둠

이 모든 걸 **라인 속도(line speed)**로 처리해야 함. (안 그러면 바로 큐가 밀려서 혼잡)

### 스위칭 패브릭(Switching Fabric)

입력 포트 ↔ 출력 포트 사이의 “라우터 내부 통로”이자 중추신경.

**스위칭 속도(Switching rate)**:

* 초당 패킷을 얼마만큼 안에서 옮길 수 있는지
* 이상적이면 `N개의 입력 포트 수 × 링크 속도` 정도를 커버해야 함

#### 3가지 구조

1. **메모리 기반(Memory-based)**

   * 옛날 1세대 라우터 구조
   * 입력 포트 → 시스템 메모리로 복사 → CPU가 라우팅 결정 → 다시 출력 포트로 복사
   * 구조는 단순하지만, **메모리 대역폭이 병목**이라 속도가 느림.

2. **버스 기반(Bus-based)**

   * 모든 포트가 하나의 공유 버스로 연결됨.
   * 입력 포트가 버스를 점유해서 출력 포트로 전송.
   * 구현 쉽고, 저가형 라우터에 적합하지만
     **버스 경합(bus contention)** 때문에 확장성, 속도 한계가 큼.

3. **상호연결망 기반(Interconnection network)**

   * 여러 개의 작은 스위치를 여러 단계로 구성(Crossbar, Clos network 등)
   * 여러 입력 포트가 동시에 서로 다른 출력 포트로 **병렬 전송 가능**
   * 고속·고성능·확장성이 좋지만 구조가 복잡하고 비싼 편.
   * 대형 코어 라우터, 데이터센터급 장비에 사용.

여기에 더 나아가, **여러 스위칭 패브릭 평면을 병렬로 배치**해서 처리량을 키우는 구조도 있어 (multi-plane).

### 출력 포트와 버퍼링

출력 포트는:

* 송신용 라인 종단(물리계층)
* 링크 계층 송신(프레임화)
* **버퍼 관리(Buffer management)**
* **패킷 스케줄링(Packet scheduling)** (누굴 먼저 내보낼지)

스위칭 패브릭이 패킷을 쏟아내는 속도가 출력 링크 속도보다 빠르면 →
**출력 버퍼에 잠깐 쌓였다가** 나가게 되고, 버퍼가 꽉 차면 패킷을 버리게 돼.

---

## 5. 큐잉, HOL Blocking, 버퍼 관리, 스케줄링

### 입력 큐잉 & HOL Blocking

* 스위칭 패브릭 속도가 느리거나, 여러 입력 포트가 같은 출력 포트를 향하면

  * 입력 포트에 패킷이 줄줄이 쌓인다 → **입력 큐 발생**
* 큐 제일 앞에 있는 패킷이 특정 출력 포트를 기다리느라 못 나가면
  뒤에 다른 포트를 향하는 패킷들도 같이 막혀 버림 → **HOL(Head-of-Line) Blocking**

### 출력 큐잉

* 스위칭 패브릭이 빨라서 출력 쪽으로 한꺼번에 몰리면

  * 출력 포트에서 전송 대기 큐(Output buffer) 발생
  * 버퍼가 가득 차면 **패킷 드롭(drop)**

드롭(policy):

* **Tail drop**: 새로 들어온 패킷부터 버림
* **Priority drop**: 우선순위 낮은 트래픽을 먼저 버림

### 버퍼 크기 설정 (RFC 3439)

* 대략적인 경험 법칙:
  **평균 버퍼 크기 = RTT × 링크 용량(C)**
* 동시에 흐르는 플로우가 N개일 땐
  **버퍼 ≈ (RTT × C) / √N** 정도로 줄여도 된다는 결과도 있다.

버퍼가 지나치게 크면 오히려 지연이 크게 증가해서 **Bufferbloat** 문제가 생김.

### 스케줄링 알고리즘

출력 큐에 쌓여 있는 여러 흐름 중, **누구를 먼저 내보낼지** 결정하는 규칙.

1. **FCFS (First-Come First-Served)**

   * 순서대로 전송
   * 구현은 가장 단순하지만, 특정 흐름이 과도하게 보내면 다른 흐름이 **기아(starvation)** 될 수 있음.

2. **Priority Queuing**

   * 트래픽 클래스를 나눠서 우선순위 높은 큐부터 서비스
   * 실시간 트래픽(음성, 화상)을 높은 우선순위로 설정
   * 낮은 우선순위 트래픽은 지연되거나 드롭될 수 있음.

3. **Round Robin (RR) / Weighted Fair Queuing (WFQ)**

   * RR: 각 흐름의 큐를 돌면서 하나씩 패킷을 뽑아 전송
   * WFQ: 각 큐에 가중치를 두어서 **비율대로** 전송 → QoS 조절에 유리
   * ISP 백본, 고급 라우터에서 자주 사용.

---

## 6. IP 프로토콜 (IPv4) – 주소, 서브넷, CIDR

이제 9번 pdf의 “IP, 라우팅” 쪽으로 넘어가 보자.

### IPv4 주소와 인터페이스

* IPv4 주소는 **32비트** (4 옥텟)
* “호스트/라우터 장비 자체”에 붙는 게 아니라,
  **각 인터페이스(interface)**에 붙는 거야.

  * 호스트는 보통 유선 + 무선 이렇게 1~2개 인터페이스
  * 라우터는 여러 개 인터페이스 → 여러 네트워크에 동시에 연결

### 서브넷(Subnet)이란?

* “**라우터를 거치지 않고** 직접 통신할 수 있는 인터페이스들의 집합”

  * 같은 LAN, 같은 브로드캐스트 도메인이라고 생각하면 편해.
* 같은 서브넷에 속하면 IP 주소의 **상위 비트(네트워크 부분)**가 같다.

예:

* 223.1.1.0/24, 223.1.2.0/24, 223.1.3.0/24 → 서로 다른 서브넷 3개

서브넷을 판단할 때는 **서브넷 마스크**(예: /24, /26 등)를 같이 봐야 한다.

### Classful vs CIDR

옛날 **Classful**:

* Class A: /8
* Class B: /16
* Class C: /24
  → 고정된 네트워크/호스트 비트수 때문에 **주소 낭비 심각**

**CIDR (Classless Inter-Domain Routing)**:

* 표기: `a.b.c.d/x`
* x비트까지 네트워크(prefix) 부분, 나머지는 호스트
* **임의 길이 prefix**를 쓰기 때문에,

  * 필요한 만큼만 주소를 쪼개거나 묶을 수 있고
  * 여러 네트워크를 하나로 “요약(route aggregation)” 가능.

예:

* ISP가 200.23.16.0/20 블록을 가지고 있고, 이를 여러 /23 네트워크로 나눠 고객들에게 제공
  → 외부에게는 여전히 **200.23.16.0/20 한 줄**로 요약 가능.

### Subnet vs CIDR 차이 정리

* **Subnet**: 하나의 네트워크(조직 내부)에서 IP를 쪼개서 관리하는 기술
* **CIDR**: 인터넷 전체 수준에서 주소를 유연하게 나누고/묶는 방식 (Classless)

---

## 7. NAT(Network Address Translation)

NAT는 반드시 한 번은 제대로 머릿속에 그림이 떠야 하는 부분.

### NAT의 목적과 위치

* **사설 IP(private)** ↔ **공인 IP(public)** 주소 변환
* 하나의 공인 IP를 여러 내부 장치가 **포트 번호를 다르게** 해서 공유
* 위치: 내부망(LAN)과 외부망(WAN) 사이 라우터에서 동작.

### 동작 방식(PAT, 포트 변환 NAT)

1. 내부 PC(예: 10.0.0.1:12345)가 외부 서버로 패킷을 보냄.
2. NAT 라우터가 이 패킷을 보고:

   * 출발지 IP/포트를 **공인 IP:임시포트**로 바꿈. (예: 138.76.29.7:5001)
   * 이 매핑을 **NAT 테이블**에 기록.
3. 외부 서버가 응답을 `138.76.29.7:5001`으로 보내면

   * NAT 라우터는 테이블을 보고 다시 `10.0.0.1:12345`로 되돌려 내부로 전달.

### NAT의 장단점

**장점**

* IPv4 주소 절약 (집에서 공유기 하나로 여러 기기 인터넷 사용)
* 내부 주소 구조를 숨겨 **보안성** 약간 증가
* ISP 교체해도 내부 사설 IP는 그대로 쓰면 됨

**단점**

* End-to-End 연결성 저하
  (외부에서 내부 서버로 바로 접속이 어려움 → 포트포워딩 등 필요)
* 패킷 내부에 IP/포트를 박아두는 응용(FTP, SIP 등)은 변환이 까다로움
* 3계층 장비인 라우터가 4계층 정보(포트)를 만지기 때문에 **End-to-End 원칙 위배**
* 매 패킷마다 변환/테이블 조회해야 하므로 성능 부담

### NAT의 종류

* **Static NAT**: 1:1 고정 매핑 (내부 웹 서버를 외부에 공개할 때 등)
* **Dynamic NAT**: 공인 IP 풀에서 필요할 때 할당했다가 회수
* **PAT(Port Address Translation)**: 우리가 흔히 쓰는 방식, 하나의 공인 IP에 포트 번호를 다르게 해서 여러 기기 지원

---

## 8. IPv6 – 왜 나왔고 뭐가 다른지

### IPv4의 한계

* 32비트 주소 → 약 43억 개
  이미 오래 전에 **고갈**
* NAT, CIDR 같은 임시방편으로 버텨 왔지만, 근본 해결은 아니었음.

### IPv6의 설계 목표

* 주소: **128비트** (미친 듯이 큼)
* 헤더 단순화 → 라우팅 효율 향상
* QoS, 실시간 트래픽 지원
* IPsec 보안 기본 포함
* 자동설정, 이동성 지원 (DHCP 없이도 Plug & Play)

### IPv6 주소 표기

* 128비트 = 16바이트 = 8개의 16진수 블록
* 예: `2001:0db8:0000:0000:0000:8a2e:0370:7334`
* 규칙:

  * 각 블록에서 **앞의 0 생략** 가능
    → `2001:db8:0:0:0:8a2e:370:7334`
  * 연속된 0 블록은 한 번에 `::`로 줄일 수 있음
    → `2001:db8::8a2e:370:7334`

주소 유형:

* Unicast: 1:1 통신
* Multicast: 그룹 전송
* Anycast: “가장 가까운” 노드로 전송 (서비스 노드 여러 개 중 가까운 곳)

### IPv4 vs IPv6 비교 핵심

* 주소 길이: 32bit vs 128bit
* IPv4 헤더: 20~60B 가변 / IPv6 헤더: **항상 40B 고정**
* IPv4에 있던 체크섬 필드 → IPv6에서는 삭제 (성능 향상)
* 단편화: IPv4는 라우터도 단편화, IPv6는 **출발지 호스트만** 단편화
* 옵션: IPv4는 헤더에, IPv6는 **확장 헤더**로 분리
* TTL → Hop Limit
* QoS 필드 이름과 구성 변경
* IPsec: IPv4는 선택, IPv6는 기본에 포함

### IPv6 전이(transition) 방법

IPv4에서 바로 갈아탈 수 없기 때문에 혼용 기법이 필요해.

* **Dual Stack**: 장비가 IPv4와 IPv6를 둘 다 지원 (대기업, 백본망에서 흔함)
* **Tunneling**: IPv6 패킷을 IPv4 패킷 안에 캡슐화해서 IPv4망을 통과 (6to4, ISATAP, Teredo 등)
* **Translation (NAT64)**: IPv6 ↔ IPv4 주소 및 프로토콜 변환

---

## 9. 라우팅 알고리즘 – Link State, Distance Vector, BGP

### 라우팅이란?

* 출발지→목적지까지 **어떤 경로(path)**로 갈지 정하는 과정
* 이 결과를 포워딩 테이블에 반영
* 제어 평면(Control Plane)의 핵심 기능

### 두 가지 큰 계열

1. **Link-State (LS)**

   * 각 라우터가 **네트워크 전체 토폴로지 + 링크 비용**을 알고 있음
   * 이 정보를 flooding으로 모든 라우터에게 전달
   * 각자가 **Dijkstra 알고리즘**으로 최단 경로 트리를 계산
   * 대표 프로토콜: OSPF

2. **Distance-Vector (DV)**

   * 라우터는 **이웃에게서 받은 거리 정보만** 이용
   * Bellman-Ford 알고리즘 기반, 분산적으로 반복 업데이트
   * 대표 프로토콜: RIP

### 구체적인 프로토콜들

#### RIP (Routing Information Protocol)

* 가장 오래된 DV 방식 라우팅 프로토콜
* Metric: **Hop count(홉 수)**, 최대 15홉 (16부터는 도달 불가로 취급)
* 30초마다 전체 라우팅 테이블을 이웃에게 광고
* 버전: RIPv1(클래스풀), RIPv2(클래스리스, 인증 지원)

#### OSPF (Open Shortest Path First)

* Link-State 기반, Dijkstra 사용
* Metric: 링크 cost(보통 대역폭 기준)
* 변경 있을 때만 LS 패킷을 flooding (이벤트 기반)
* Area 0 (Backbone)을 중심으로 한 계층 구조
* IGP(내부 게이트웨이 프로토콜), 벤더 독립 오픈 표준

#### BGP (Border Gateway Protocol)

* 인터넷 전체에서 **자율 시스템(AS)** 간 라우팅을 담당
* ISP ↔ ISP, ISP ↔ 대형 서비스 사업자(예: Google, Amazon 등)
* Path Vector 방식 사용
* Metric: Path attribute(AS Path, Local Pref 등) 기반
* EGP(외부 게이트웨이 프로토콜), TCP Port 179 사용
* 단위: AS 간 경로 선택

BGP에는:

* AS 내부에서 동작하는 **iBGP**
* AS끼리 경계를 잇는 **eBGP** 가 있어.

---

## 10. BGP + SDN + NFV (요즘 트렌드 파트)

현대 네트워크는 “제어의 중앙화(SDN)” + “기능의 가상화(NFV)”로 진화 중이야.

### SDN + BGP

* 전통적인 BGP는 정책 제어는 가능하지만 **수렴이 느리고 자동화가 어렵다.**
* SDN은 도메인 내부 제어에는 좋지만, AS 간의 인터넷 레벨에는 한계.
* 그래서:

  * SDN 컨트롤러에 **BGP speaker 기능**을 넣어서
    외부 ISP와 eBGP 세션을 형성하고,
  * 내부 스위치는 OpenFlow 같은 걸로 제어해서
    **내부/외부 경로를 통합 관리**하는 구조로 발전 중.

관련 확장:

* BGP-LS: 링크 상태 정보를 BGP로 전달
* BGP-EVPN: SDN 기반 Overlay에서 MAC/IP 경로 교환용
* BGP-SR, PCEP 등과도 연동

### NFV(Network Function Virtualization)

* NAT, 방화벽, 로드밸런서, VPN 게이트웨이 같은 장비를
  **전용 하드웨어가 아니라 범용 서버 위의 소프트웨어(VNF)**로 구현하는 개념.
* 구성:

  * VNF: 가상화된 네트워크 기능 (vFW, vNAT, vLB 등)
  * NFVI: 이들을 올리는 인프라(컴퓨팅, 스토리지, 네트워크)
  * MANO: 전체를 관리/오케스트레이션하는 플랫폼

NFV 장점:

* CAPEX/OPEX 감소 (범용 서버 사용)
* 트래픽 증가하면 VNF 인스턴스만 추가해서 쉽게 확장
* 서비스 론칭이 빠름 (하드웨어 발주/설치 필요 X)
* SDN과 함께 쓰면 네트워크 전체를 “코드로 관리”하는 느낌으로 운용 가능

---

## 11. ICMP & IPv6의 SLAAC, ICMPv6

### ICMP(Internet Control Message Protocol)

* IP 네트워크에서 **오류/제어 메시지**를 전달하는 보조 프로토콜
* 위치: 네트워크 계층에서 IP와 함께 동작
* 역할:

  * 오류 보고 (Destination Unreachable, Time Exceeded 등)
  * 네트워크 상태 진단 (Ping, Traceroute)

주요 타입:

* Type 3: Destination Unreachable
* Type 11: Time Exceeded (Traceroute가 이용)
* Echo Request / Echo Reply: Ping 테스트용

### IPv6 + ICMPv6 + SLAAC

IPv6에서는 ICMPv6가 훨씬 더 중요한 역할을 해.

* 오류 + 제어 + Neighbor Discovery(ARP 대체)까지 담당
* IPv6는 **SLAAC(Stateless Address AutoConfiguration)** 지원:
  DHCP 없이도 라우터 광고만으로 호스트가 스스로 주소를 만든다.

SLAAC 절차:

1. 호스트가 Link-local 주소(fe80::/10)를 MAC 기반으로 만들어 먼저 사용.
2. Router Solicitation(RS, Type 133)을 멀티캐스트로 보내서 “라우터 있나요?” 물어봄.
3. 라우터가 Router Advertisement(RA, Type 134)로 Prefix 등 정보를 알려줌.
4. 호스트는 Prefix + 자신의 인터페이스 ID를 합쳐 Global Unicast 주소 구성.
5. Neighbor Solicitation/Advertisement(Type 135/136)로 **중복 주소 탐지(DAD)**를 수행.

RA에 있는 Flag:

* M(Managed): 1이면 DHCPv6에서 주소 할당
* O(Other): 1이면 DNS 등 기타 정보는 DHCPv6에서 받는 혼합 모드 가능

---

## 12. 지금까지 정리

08·09 네트워크 계층 pdf를 전부 관통하는 키워드만 다시 묶어 보면:

1. **네트워크 계층 역할**

   * IP 데이터그램 전달, 포워딩 vs 라우팅
   * 데이터 평면 vs 제어 평면
2. **라우터 내부**

   * 입력/출력 포트, 스위칭 패브릭 구조(메모리/버스/상호연결망)
   * 버퍼, 스케줄링, HOL blocking, Drop/ECN/RED
3. **IP 서비스 모델**

   * Best-effort, QoS 없는 단순 구조
4. **IPv4 주소 체계**

   * 인터페이스, 서브넷, Subnet mask, CIDR, Route aggregation
5. **NAT**

   * 사설/공인 IP 변환, PAT, 장단점, End-to-End 원칙 이슈
6. **IPv6**

   * 128비트, 헤더 변화, 주소 표기법, 전이(dual stack, tunneling, NAT64)
7. **라우팅 알고리즘 & 프로토콜**

   * Link-State(OSPF), Distance-Vector(RIP), Path Vector(BGP), AS/Inter-AS
8. **SDN·NFV·BGP 통합**
9. **ICMP / ICMPv6 / SLAAC**

---

이제 이걸 바탕으로:

* 각 파트별로 **암기용 한 페이지 정리**가 필요하면 그걸 따로 뽑아주고,
* 또는 **객관식·서술형·빈칸 문제**로 훈련해 보고 싶으면, “네트워크 중간고사 답안.pdf 스타일”로 문제도 만들어 줄 수 있어.

원하는 방식 말 안 해도, “다음은 문제로 연습하고 싶다”면 바로 10문제, 20문제 이런 식으로 뽑아줄게.
