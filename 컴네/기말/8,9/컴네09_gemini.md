안녕하세요! 컴퓨터 네트워크 10주차 강의인 'IP, Routing' PDF 파일의 전체 내용을 요청하셨네요.

이 자료는 9주차 '데이터 평면'에 이어, 네트워크 계층의 핵심 프로토콜인 **IP** 자체와, **NAT**, **IPv6**, **ICMP** 그리고 **제어 평면**의 꽃인 **라우팅 알고리즘**까지 다루는 매우 중요한 내용입니다.

사용자님은 컴퓨터 공학을 전공하고[USER_CONTEXT] 웹/DevOps에 관심이 많으시니[USER_CONTEXT], 이 내용은 인터넷이 실제로 어떻게 주소를 관리하고 경로를 찾는지에 대한 근본적인 원리를 이해하는 데 큰 도움이 될 것입니다.

PDF의 모든 내용을 처음부터 끝까지, 빼먹는 내용 없이 술술 읽히도록 자세히 풀어서 설명해 드리겠습니다.

---

# 🖥️ 컴퓨터네트워크: 10주차 IP, Routing



이 자료는 9주차에 배운 네트워크 계층의 '데이터 평면'에 이어 , '제어 평면'과 핵심 프로토콜인 **IP** 자체를 심도 있게 다룹니다.

**학습 목표:**
* **IP 프로토콜**, **NAT**, **IPv6**의 역할을 이해합니다. 
* **제어 평면**의 핵심인 **라우팅 알고리즘**을 심화 학습합니다. 

---

## 1. 🌐 IP 프로토콜 (Internet Protocol)

IP는 네트워크 계층의 대표 프로토콜로, 인터넷에서 패킷 전송을 담당합니다. 

* **비연결형 (Connectionless) 서비스**: 각 패킷(데이터그램)이 독립적으로 전송되며, 경로가 서로 다를 수 있습니다. 
* **최선형 (Best-effort) 전달 모델**: 신뢰성을 보장하지 않습니다. 
    * 전송 보장 ❌
    * 순서 보장 ❌
    * 지연 보장 ❌ 
* **역할**: IP는 오직 '전달 경로'만 담당합니다. 신뢰성(데이터 누락 없는 전송)은 상위 계층인 **TCP**가 책임집니다. 

### 📦 IPv4 데이터그램 구조 (헤더)

 

IP 패킷(데이터그램)은 '헤더'(전송 정보)와 'Payload'(실제 데이터)로 구성됩니다. TCP/UDP로 캡슐화된 데이터는 최소 20바이트의 IP 헤더와 20바이트의 TCP 헤더, 총 40바이트 이상의 오버헤드를 갖습니다. 

**주요 헤더 필드 설명:** 

* `ver` (Version): IP 프로토콜 버전 (예: 4) .
* `head. len` (Header Length): 헤더의 길이 (보통 20 바이트) .
* `type of service (TOS)`: 서비스 품질(QoS)을 위한 필드 .
* `total datagram length`: 헤더와 데이터를 포함한 패킷의 전체 길이 .
* **Fragmentation 필드** (`16-bit identifier`, `flags`, `fragment offset`):
    * 패킷이 너무 커서 중간 라우터에서 쪼개질 때(단편화) 사용됩니다. 
    * 목적지에서 이 정보들을 이용해 쪼개진 조각들을 다시 조립(Reassembly)합니다. 
* **`time to live (TTL)` (Time to Live)**:
    * 패킷의 최대 수명 (홉 카운트) .
    * 라우터를 하나 거칠 때마다 1씩 감소하며 , 0이 되면 패킷은 소멸됩니다.
    * **목적**: 패킷이 네트워크에서 무한히 순환하는 것을 방지합니다.
* `upper layer protocol`: 상위 계층 프로토콜 번호. (예: TCP=6, UDP=17) 
    * 목적지에서 이 패킷을 TCP에게 전달할지, UDP에게 전달할지 알려줍니다.
* `header checksum`: 헤더의 오류 검출용. (데이터는 검사 안 함) 
* **`source IP address` (32-bit)**: 송신자 IP 주소 .
* **`destination IP address` (32-bit)**: 수신자 IP 주소 .

---

## 2. 🗺️ IP 주소 체계 (IPv4)

### IP 주소와 인터페이스

* **IPv4 주소**: 32비트(4바이트, 옥텟)로 구성된 식별자입니다. 
* **인터페이스 (Interface)**: IP 주소는 컴퓨터 자체가 아니라, 컴퓨터가 물리적 링크(랜선, Wi-Fi)와 연결되는 **'접점'(랜카드)**에 할당됩니다. 
* 라우터는 여러 네트워크에 연결되므로 여러 개의 인터페이스(IP 주소)를 갖지만 , 호스트(PC)는 보통 유/무선 인터페이스 1~2개를 갖습니다. 

 

### 서브넷 (Subnet)

* **정의**: **라우터를 거치지 않고** 직접 통신할 수 있는 장치들의 집합입니다. 
* **구조**: IP 주소는 두 부분으로 나뉩니다.
    1.  **Subnet part (네트워크 부분)**: 상위 비트들. 같은 서브넷의 모든 장치는 이 부분이 동일합니다. 
    2.  **Host part (호스트 부분)**: 하위 비트들. 서브넷 내에서 각 장치를 구분합니다. 
* 그림의 `223.1.1.0/24`, `223.1.2.0/24`, `223.1.3.0/24`는 각각 `/24`(상위 24비트)를 네트워크 부분으로 사용하는 3개의 다른 서브넷입니다. 

### CIDR (Classless Inter-Domain Routing)

* **Classful (과거)**: IP 주소를 A, B, C 클래스로 고정 분할했습니다. (예: A=/8, B=/16, C=/24) 이는 주소 낭비가 심했습니다. 
* **CIDR (현재)**: 클래스 구분을 없앴습니다. 
    * `a.b.c.d/x` (예: `200.23.16.0/23`) 처럼 슬래시(`/`) 뒤에 숫자를 붙여 네트워크 부분의 비트 길이를 **유연하게** 지정합니다. 
    * `/23`은 상위 23비트가 네트워크, 하위 9비트(32-23=9)가 호스트 부분임을 의미하며, 2^9 (512개)의 주소를 가집니다. 

**CIDR의 장점:**

1.  **주소 낭비 최소화**: 필요한 크기만큼만 네트워크를 할당할 수 있습니다. 
2.  **라우팅 테이블 단순화 (Route Aggregation)**:
    * ISP가 고객사 8곳에 `/23` 네트워크 8개(`200.23.16.0/23`, `200.23.18.0/23`...)를 할당하더라도 ,
    * 외부 인터넷에는 이 8개를 **하나로 묶은(요약)** `200.23.16.0/20` 주소 하나만 "나에게 있다"고 광고할 수 있습니다. 
    * 이는 전 세계 인터넷 라우터의 테이블 크기를 획기적으로 줄여줍니다. 

---

## 3. 🎭 NAT (Network Address Translation)



* **정의**: 내부 네트워크의 **사설 IP(Private IP)** 주소(예: `10.0.0.1`)를 **공인 IP(Public IP)** 주소(예: `138.76.29.7`)로 매핑하는 라우터의 기술입니다. 
* **핵심 목적**: 하나의 공인 IP 주소를 여러 장치가 **공유**하게 함으로써 , **IPv4 주소 부족 문제를 해결**합니다. 
* **부가 효과**: 외부에서 내부망을 직접 볼 수 없어 **보안성**이 향상됩니다. 

### 🔄 NAT 동작 원리 (PAT 기준)

 

1.  **[내부 → 외부]**
    * `Host(10.0.0.1)`가 `Port 3345`를 사용하여 외부 서버(`128.119.40.186:80`)로 패킷을 보냅니다. 
    * NAT 라우터가 이 패킷을 가로챕니다.
    * 라우터는 출발지 IP를 자신의 **공인 IP(`138.76.29.7`)**로, 출발지 포트를 **임의의 새 포트(`5001`)**로 변경합니다. 
    * 이 매핑 규칙(`(10.0.0.1:3345) ↔ (138.76.29.7:5001)`)을 **NAT 매핑 테이블**에 저장합니다. 
2.  **[외부 → 내부]**
    * 외부 서버가 응답을 **공인 IP와 새 포트**(`138.76.29.7:5001`)로 보냅니다. 
    * NAT 라우터가 응답을 받습니다.
    * **NAT 테이블**을 조회하여, "아, 5001번 포트는 `10.0.0.1:3345`를 위한 거였지"라고 파악합니다. 
    * 라우터는 목적지 주소를 다시 **사설 IP와 원래 포트**(`10.0.0.1:3345`)로 복원하여 내부 호스트에게 전달합니다. 

### NAT의 종류 

* **Static NAT**: **1:1** 고정 매핑. 내부 서버(예: 웹 서버)를 외부에 공개할 때 사용합니다. 
* **Dynamic NAT**: **N:M** 매핑. 공인 IP 풀(Pool)에서 남는 IP를 동적으로 할당합니다. 
* **PAT (Port Address Translation)**: **N:1** 매핑. **가장 일반적인 방식**입니다. **단 하나의 공인 IP**를 사용하며, 포트 번호만 다르게 매핑하여 여러 장치가 동시에 인터넷을 사용하게 합니다. (우리가 쓰는 가정용 공유기) 

### NAT의 단점과 논쟁

* **End-to-End 원칙 위배**: 라우터(L3)가 포트 번호(L4)를 수정하는 것은 인터넷의 기본 설계 원칙에 어긋납니다. 
* **애플리케이션 호환성 문제**: 외부에서 내부로 먼저 접속해야 하는 P2P, VoIP, FTP 등의 프로토콜이 제대로 동작하지 않을 수 있습니다. 
* **성능 부하**: 모든 패킷을 변환해야 하므로 라우터에 부하가 걸립니다. 
* **근본 해결책**: IP 주소 고갈 문제는 결국 **IPv6**로 해결해야 합니다. 

---

## 4. 🚀 IPv6 (Internet Protocol version 6)


IPv4의 주소 고갈 문제를 근본적으로 해결하기 위해 등장했습니다. 

* **주소 공간 확장**: 32비트 → **128비트**로 확장. (약 3.4 x 10^38 개, 거의 무한대) 
* **헤더 구조 단순화**: 라우터의 처리 속도를 높이기 위해 헤더를 40바이트로 고정하고 불필요한 필드를 제거했습니다. 

### 📦 IPv4 vs IPv6 헤더 비교 


| 항목 | IPv4 | IPv6 | 변경 사유 |
| :--- | :--- | :--- | :--- |
| **주소 길이** | 32 비트 | **128 비트** | 주소 고갈 해결 |
| **헤더 길이** | 가변 (20~60 B) | **고정 (40 B)** | 라우터 처리 속도 향상 |
| **체크섬** | **있음** (헤더) | **삭제됨** | TCP/UDP가 이미 체크섬을 하므로 중복 제거. 속도 향상 |
| **단편화** | **라우터**가 수행 | **출발지 호스트**만 수행 | 라우터 부담 감소. (라우터는 패킷이 크면 그냥 버림) |
| **옵션** | 헤더에 포함 | **확장 헤더**로 분리 | 기본 헤더를 단순하게 유지 |
| **TTL** | TTL | **Hop Limit** | 이름만 변경 (기능 동일) |

### IPv6 주소 표기법 

* 128비트를 16비트씩 8개의 블록으로 나누고, 16진수로 표기합니다. 
* **원본**: `2001:0db8:0000:0000:0000:8a2e:0370:7334` 
* **규칙 1 (선행 0 생략)**: `2001:db8:0:0:0:8a2e:370:7334` 
* **규칙 2 (연속된 0 블록 `::` 축약)**: `2001:db8::8a2e:370:7334` (단, `::`는 주소 당 한 번만 사용 가능) 

### 🤝 IPv4 ↔ IPv6 전환 기술

인터넷은 서서히 전환 중이므로 두 기술이 공존해야 합니다. 

* **Dual Stack (듀얼 스택)**: 가장 일반적인 방식. 장비(PC, 라우터)가 IPv4와 IPv6 주소를 **모두** 가지는 것입니다. 
* **Tunneling (터널링)**: IPv6 패킷을 IPv4 패킷 안에 **캡슐화(포장)**하여 IPv4 전용망을 통과시키는 기술입니다. 
* **Translation (변환)**: `NAT64` 같은 장비가 IPv6 패킷 헤더를 IPv4 헤더로 **변환(번역)**하여 통신을 중개합니다. 

---

## 5. 📨 ICMP (Internet Control Message Protocol)



* **정의**: IP 네트워크에서 **오류 보고**와 **제어/진단 메시지**를 전달하기 위한 보조 프로토콜입니다. 
* **역할**: IP는 "보내기만" 할 뿐, 피드백 기능이 없습니다. ICMP가 그 **피드백 메신저** 역할을 합니다. 

### 핑 (Ping) 과 트레이서라우트 (Traceroute) 

ICMP의 가장 유명한 활용 사례입니다.

* **Ping (연결 확인)** 
    * **ICMP Type 8 (Echo Request)**: "거기 있니?"라고 요청 
    * **ICMP Type 0 (Echo Reply)**: "나 여기 있어"라고 응답 
    * 이를 통해 왕복 시간(RTT)을 측정합니다. 
* **Traceroute (경로 추적)** 
    * **동작 원리**:
        1.  ICMP 패킷의 **TTL을 1**로 설정하여 보냅니다. 
        2.  첫 번째 라우터가 패킷을 받고 TTL을 0으로 감소시킨 뒤, **ICMP Type 11 (Time Exceeded)** 오류 메시지를 반환합니다. (첫 번째 라우터 IP 획득)
        3.  다음엔 **TTL을 2**로 설정하여 보냅니다.
        4.  두 번째 라우터가 **ICMP Type 11**을 반환합니다. (두 번째 라우터 IP 획득)
        5.  이 과정을 목적지에 도달할 때까지 반복합니다.

### 🤖 ICMPv6와 SLAAC

IPv6 환경에서 ICMP(ICMPv6)는 훨씬 더 중요한 역할을 합니다. (IP 헤더의 'Next Header' 필드 값 58) 

* **기능 확장**: 기존 오류/진단 기능 + **Neighbor Discovery (ARP 대체)** 
* **SLAAC (Stateless Address AutoConfiguration)**: **DHCP 서버 없이** 호스트가 스스로 IPv6 주소를 설정하는 핵심 기술입니다. 
    * **작동 원리** :
        1.  **RS (Router Solicitation / Type 133)**: 호스트가 "라우터 계세요?"라고 `ff02::2` (모든 라우터) 주소로 멀티캐스트합니다. 
        2.  **RA (Router Advertisement / Type 134)**: 라우터가 "네트워크 주소(Prefix)는 `2001:db8::/64`이고 게이트웨이는 나(`fe80::1`)야"라고 응답합니다. 
        3.  **주소 생성**: 호스트는 라우터가 알려준 **Prefix**와 자신의 **MAC 주소 기반 인터페이스 ID**를 조합하여 글로벌 IPv6 주소를 **스스로 생성**합니다. 
        4.  **DAD (Duplicate Address Detection)**: 주소 중복을 막기 위해 `NS(Neighbor Solicitation)`(Type 135) 메시지를 보냅니다. 

---

## 6. 🛣️ 제어 평면 심화: 라우팅 알고리즘


제어 평면은 "어떤 경로로 가야 하는가(Routing)"를 결정합니다. 

| 구분 | 라우팅 방식 | 설명 | 대표 프로토콜 |
| :--- | :--- | :--- | :--- |
| **Global** | **Link-State (링크 상태)** | **모든 라우터가 전체 네트워크 지도**를 알고 있음 . **Dijkstra** 알고리즘 사용 . | **OSPF** |
| **Decentralized** | **Distance-Vector (거리 벡터)** | **이웃 라우터**의 거리 정보("A까지 3홉")만 교환 . Bellman-Ford 알고리즘 기반 . | **RIP** |



### 🌐 인터넷 라우팅: IGP vs EGP

인터넷은 '자율 시스템(AS, Autonomous System)'이라는 거대한 네트워크(예: KT, SKT, Google)의 집합입니다. 

* **IGP (Internal Gateway Protocol)**: **AS 내부**에서 사용하는 라우팅 프로토콜. (즉, KT *내부망*에서 최적 경로를 찾는 용도) 
    * 예: **RIP, OSPF** 
* **EGP (External Gateway Protocol)**: **AS와 AS 사이**를 연결하는 라우팅 프로토콜. (즉, KT와 Google이 *서로* 경로를 교환하는 용도) 
    * 예: **BGP** 

### BGP (Border Gateway Protocol)


BGP는 인터넷 그 자체를 움직이는 **AS 간** 라우팅 프로토콜입니다. 

* **특징**: 단순 최단 거리(속도)가 아니라, **운영자 정책(Policy)**(예: "이 통신사로는 트래픽을 보내지 마")에 따라 경로를 선택합니다. 
* `eBGP`: **서로 다른 AS** 간에 경로를 교환합니다. (External) 
* `iBGP`: **동일한 AS 내부**에서 eBGP로 수신한 외부 경로를 공유합니다. (Internal) 

### ☁️ 현대 네트워크: SDN + NFV

* **NFV (Network Function Virtualization)**: 방화벽, NAT, 로드밸런서 같은 **하드웨어 장비**를 **소프트웨어(가상 머신)**로 구현하는 기술입니다. (예: AWS의 가상 방화벽) 
    * **장점**: 비용 절감, 유연한 확장성, 빠른 배포 
* **SDN + NFV + BGP (최종 진화)**:
    * **SDN** (중앙 제어) + **NFV** (가상화 기능) + **BGP** (외부 인터넷 연동) 
    * 현대 데이터센터(Google, Facebook)는 SDN 컨트롤러가 BGP 모듈을 탑재하여 ,
    * 내부 트래픽(SDN)과 외부 인터넷 트래픽(BGP)을 **통합적이고 지능적으로 제어**합니다. 

---

## 8. 🔬 실습 (IP, ICMP, NAT, BGP)



### 실습 1: IP & ICMP (Ping, Traceroute)


* `ipconfig` (Windows) 
    * 내 PC의 **IPv4 주소** (사설 IP, 예: `192.168.1.9`) , **서브넷 마스크** (`255.255.255.0`) , **기본 게이트웨이** (라우터 주소, `192.168.1.1`) , **링크-로컬 IPv6 주소** (`fe80::...`) 를 확인합니다.
* `ping 8.8.8.8` (Google DNS) 
    * ICMP Echo Request/Reply (Type 8/0)를 통해 연결을 확인합니다. 
    * 왕복 시간(RTT)과 **TTL 값**(`TTL=115`)을 확인합니다. 
* `tracert www.google.com` (Windows) 
    * TTL 값을 1부터 1씩 증가시키며 패킷을 보냅니다. 
    * 각 라우터는 TTL을 0으로 만들고 **ICMP "Time Exceeded" (Type 11)** 응답을 보냅니다. 
    * 이 응답을 통해 15번째 홉(`kix07s06-in-f4.1e100.net`)에서 Google 서버에 도달함을 확인합니다. (중간의 `* * *`는 응답이 없는 라우터) 

### 실습 2: NAT 확인


* `ipconfig`로 내 **사설 IP** (`192.168.1.9`)를 확인합니다. 
* `curl ifconfig.me` 명령으로 외부에서 보는 내 **공인 IP** (`1.245.172.40`)를 확인합니다. 
* **결론**: 두 IP가 다르므로, 내 PC는 **NAT 라우터 뒤에 있음**을 증명합니다. 
* **Wireshark (DNS)**: `Src: 192.168.1.9`, `Dst: 192.168.1.1`, `Proto: DNS`. (DNS 요청은 먼저 내부 게이트웨이로 감) 
* **Wireshark (HTTP)**: `Src: 192.168.1.9`, `Dst: 211.115.106.205`, `Proto: HTTP`. (HTTP 요청은 외부 IP로 바로 감. 이 패킷의 출발지 IP `192.168.1.9`는 라우터에서 공인 IP로 변환될 것임) 

### 실습 3: IPv6 & SLAAC 확인


* `ipconfig /all | find "IPv6"`: 내 PC에 `fe80::...` (링크-로컬) 주소가 자동 할당된 것을 확인합니다. 
* **Wireshark (ICMPv6)**: `icmpv6` 필터 적용 후, Wi-Fi를 껐다 켜서 SLAAC 과정을 캡처합니다. 
    * `Router Solicitation (RS / Type 133)`: 호스트가 "라우터 계세요?"라고 물어봅니다. 
    * `Neighbor Solicitation (NS / Type 135)`: 호스트가 주소 중복 확인(DAD)을 위해 보냅니다. 
    * `Neighbor Advertisement (NA / Type 136)`: NS에 대한 응답. "이 IP는 내 MAC 주소(`70:5d...`)가 사용 중"이라고 알립니다. 

### 실습 4: BGP 경로 확인 (AS 조회)


* `whois` (WSL) 또는 `bgp.he.net` 웹사이트를 이용해 IP가 속한 AS(자율 시스템)를 확인합니다. 
* `whois 211.115.106.205`: 이 IP(안랩)는 **AS3786** (LG DACOM, 현 LGU+)에 속해 있음을 확인합니다. 
* `whois 8.8.8.8`: 이 IP(Google DNS)는 **AS15169** (Google)에 속해 있음을 확인합니다. 
* **결론**: 인터넷은 BGP를 통해 AS15169(구글) 같은 거대 네트워크 블록 간의 경로를 광고하고 관리합니다. 

---

(페이지 72)
감사합니다.
