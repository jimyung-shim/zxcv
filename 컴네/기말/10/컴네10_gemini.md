안녕하세요! 컴퓨터 네트워크 12주차 강의인 'Link layer, LANs' PDF 파일의 전체 내용을 요청하셨네요.

이 자료는 네트워크 계층(L3)의 바로 아래 단계인 **링크 계층(L2)**에 대해 다룹니다. 사용자님은 컴퓨터 공학을 전공하고[USER_CONTEXT] 웹/DevOps에 관심이 많으시니[USER_CONTEXT], 이 12주차 내용은 서버를 실제로 네트워크에 연결하는 물리적인 주소(MAC)와 장비(스위치), 그리고 네트워크를 분리하는(VLAN) 핵심 실무 지식입니다.

PDF의 모든 내용을 처음부터 끝까지, 빼먹는 내용 없이 술술 읽히도록 자세히 풀어서 설명해 드리겠습니다.

---

# 🖥️ 컴퓨터네트워크: 12주차 링크 계층과 LAN



이번 12주차 강의는 네트워크 스택의 2계층(L2), **링크 계층(Link Layer)**과 **LAN(Local Area Networks)**에 대해 다룹니다. 

**학습 주제:**
* 오류 검출 및 정정 (Error Detection/Correction) 
* 다중 접근 제어 (MAC) 프로토콜 
* LAN, ARP, 이더넷(Ethernet), 스위치(Switches), VLAN 

---

## 1. 📬 링크 계층의 목표와 서비스

### 링크 계층의 목표


네트워크 계층(L3)이 **전체 여행 경로(출발지-목적지)**를 책임진다면, 링크 계층(L2)은 그 경로 중 **"한 홉(one hop)"**, 즉 인접한 두 노드(예: 내 PC ↔ 라우터) 사이의 데이터 전달을 책임집니다. 

* **노드(Nodes):** 호스트(PC)와 라우터를 의미합니다. 
* **링크(Links):** 두 노드를 연결하는 유선/무선 매체입니다. 
* **프레임(Frame):** 링크 계층의 전송 단위(데이터 조각)입니다. 

네트워크 계층에서 IP 데이터그램을 전달받으면 , 링크 계층은 이를 **프레임(Frame)**으로 감싸서 물리 계층(L1)을 통해 비트(Bit)로 전송합니다. 

### 링크 계층의 주요 서비스


링크 계층은 "편지 봉투"와 같은 역할을 합니다. 
* **편지 내용:** IP 데이터그램 
* **봉투:** 프레임 헤더와 트레일러 
* **주소:** MAC 주소 
* **봉인:** 오류 검출 코드 (CRC) 

#### 1. 프레이밍 (Framing)
네트워크 계층에서 받은 IP 데이터그램을 L2 헤더(MAC 주소 등)와 트레일러(오류 검출)로 감싸는(캡슐화) 과정입니다. 

#### 2. 다중 접근 제어 (MAC: Multiple Access Control)

Wi-Fi나 초창기 이더넷처럼 하나의 "공유 매체"를 여러 노드가 동시에 사용할 때, **"누가, 언제 보낼지 결정하는 규칙"**입니다. (예: ALOHA, CSMA/CD, CSMA/CA) 

#### 3. 링크 계층 주소 지정 (MAC Address)

IP 주소(L3)와 별개로, LAN 내부에서 장치를 식별하기 위한 48비트 **물리적 주소**입니다. 
* **ARP (Address Resolution Protocol):** "IP 주소 → MAC 주소"로 변환해주는 핵심 프로토콜입니다. 

#### 4. 오류 검출 및 정정 (Error Detection / Correction)

전송 중 신호 감쇠나 잡음으로 인해 발생한 비트 오류(프레임 손상)를 확인합니다. 
* **오류 검출:** 패리티(Parity), 체크섬(Checksum), **CRC** 등이 있으며 , 오류를 *발견*하면 프레임을 폐기합니다. (이더넷은 오류 검출만 수행) 
* **오류 정정:** 재전송 요청 없이 오류를 *직접 수정*합니다. 

#### 5. 신뢰적 전송 (Reliable Delivery, *선택 사항*)

Wi-Fi처럼 오류가 잦은 무선 링크에서는, L4(TCP)까지 기다려 재전송하는 것이 비효율적이므로, L2(링크 계층)에서 직접 프레임 손실을 감지하고 빠른 재전송을 수행하기도 합니다. 

#### 6. 흐름 제어 (Flow Control)

인접한 송신 노드와 수신 노드 사이의 속도를 조절하여, 수신 측 버퍼가 넘치지 않도록 합니다. 

---

## 2. 🔌 NIC: 링크 계층은 어디에 구현되나?

링크 계층은 **NIC(Network Interface Card)**, 즉 "랜카드"에 구현되어 있습니다. 

* 네트워크에 연결되는 모든 장치(PC, 스마트폰, 라우터)는 반드시 링크 계층 기능을 내장하고 있습니다. 
* 이 기능은 CPU(소프트웨어)가 직접 처리하는 것이 아니라, **NIC 칩(하드웨어)** 또는 펌웨어에서 대부분 처리됩니다. 
* NIC는 링크 계층(L2)과 물리 계층(L1)의 기능을 모두 담당합니다. 
* NIC는 시스템 버스(예: PCI, USB)를 통해 컴퓨터의 CPU/메모리와 연결됩니다. 

 

### NIC의 동작 절차 (프레임 전송 과정)

 

1.  **송신 측 OS**: 상위 계층에서 IP 데이터그램을 생성합니다. 
2.  **송신 측 NIC Controller**: OS로부터 IP 데이터그램을 받아, MAC 주소 헤더와 CRC(FCS) 트레일러를 붙여 **프레임으로 캡슐화(프레이밍)**합니다. 
3.  **송신 측 NIC PHY**: 프레임을 전기 신호 또는 전파(비트)로 변환하여 물리적 링크로 쏩니다. 
4.  **(물리적 링크)** 
5.  **수신 측 NIC PHY**: 신호를 비트로 복원합니다. 
6.  **수신 측 NIC Controller**: 프레임을 받아 CRC(오류) 검사 후, 헤더와 트레일러를 제거(프레임 해제)합니다. 
7.  **수신 측 OS**: 오류 없는 순수 IP 데이터그램을 상위 계층(네트워크 계층)으로 전달합니다. 

---

## 3. 🔬 오류 검출/정정 기술

 
송신 측은 데이터(D)에 오류 검출 비트(EDC)를 추가하여 전송합니다 . 수신 측은 수신된 데이터(D')와 EDC'를 비교하여 오류 여부를 판단합니다 .

### ① 패리티 검사 (Parity Check)

* **1차원 패리티**: 데이터 비트의 1의 개수가 짝수(짝수 패리티) 또는 홀수(홀수 패리티)가 되도록 패리티 비트(1비트)를 추가합니다 .
    * (예: 01110001, 1이 4개(짝수) -> 짝수 패리티 비트 = 0)
    * **단점**: 2개의 비트가 동시에 바뀌면 오류를 검출하지 못합니다.
* **2차원 패리티**: 데이터를 행렬로 배치하고, 각 행과 열에 대해 패리티 비트를 계산합니다. 
    * **장점**: 오류가 발생한 행과 열을 특정하여 **단일 비트 오류를 정정(Correction)**할 수 있습니다. 

### ② 체크섬 (Checksum)

주로 TCP, UDP, IP(L3/L4)에서 사용됩니다.
1.  **송신자**: 데이터를 16비트 단위로 나누어 모두 더합니다 (1의 보수 합). 
2.  이 합의 1의 보수(값을 뒤집음)를 헤더의 체크섬 필드에 저장하여 전송합니다. 
3.  **수신자**: 받은 데이터로 1의 보수 합을 다시 계산합니다. 
4.  계산된 값과 수신된 체크섬 값이 일치하는지 비교하여 오류를 검출합니다. 

### ③ CRC (Cyclic Redundancy Check)

**가장 강력한 오류 검출 기술**로, **이더넷과 Wi-Fi**에서 사용됩니다. 
1.  송신자와 수신자가 미리 약속된 **생성 다항식(Generator, G)**을 가집니다. 
2.  송신자는 데이터(D)를 G로 나눈 **나머지(R)**를 계산하여 , 데이터 뒤에 붙여 `<D, R>` 형태로 전송합니다. 
3.  수신자는 받은 `<D, R>` 전체를 G로 나눕니다.
4.  나누어떨어지면(나머지 0) 오류가 없는 것이고, 나머지가 있으면 오류로 판단합니다. 

---

## 4. 📡 다중 접근 제어 (MAC) 프로토콜

 
링크가 점대점(PPP) 방식이 아닌, **공유 매체(Broadcast)**일 때(예: 옛날 버스형 이더넷, 현재의 Wi-Fi) , 여러 노드가 동시에 데이터를 전송하면 **충돌(Collision)**이 발생합니다. 

MAC 프로토콜은 이 충돌을 관리하고 "누가 언제 보낼지"를 결정하는 규칙입니다. 

### ① 채널 분할 (Channel Partitioning)
* **TDMA (시분할)**, **FDMA (주파수 분할)** .
* 자원을 아예 고정 할당합니다. 충돌은 없지만, 할당된 노드가 데이터를 안 보내면 자원이 낭비됩니다. 

### ② 랜덤 접근 (Random Access)
* 노드가 보낼 데이터가 있을 때마다 "눈치껏" 시도하는 방식입니다. 
* **CSMA (Carrier Sense Multiple Access)**: "Listen before transmit" (보내기 전에 듣는다). 
    * 채널이 조용한지(Carrier Sense) 확인하고, 조용하면 전송합니다. 
    * 하지만 전파 지연 때문에 여전히 충돌이 가능합니다. 
* **CSMA/CD (Collision Detection)**: **유선 이더넷(허브)**에서 사용. 
    1.  CSMA로 전송을 시작합니다.
    2.  전송 중에도 계속 들으면서 **충돌을 감지(CD)**합니다.
    3.  충돌이 감지되면 즉시 전송을 중단하고, 
    4.  **지수적 백오프(Exponential Backoff)** 알고리즘에 따라 랜덤한 시간(충돌이 반복될수록 대기 시간을 지수적으로 늘림)을 기다린 후 1번부터 다시 시도합니다. 
    * (참고: 오늘날 **스위치** 환경은 전이중(Full-duplex) 통신을 하므로 충돌이 없어 CSMA/CD가 거의 사용되지 않습니다.) 
* **CSMA/CA (Collision Avoidance)**: **Wi-Fi**에서 사용. 
    * 무선(Wi-Fi)은 전파 특성상 충돌 *감지*(CD)가 어렵습니다.
    * 따라서 충돌을 *회피*(CA)하는 방식을 씁니다. (예: 데이터를 보내기 전 RTS/CTS라는 작은 신호를 먼저 교환하여 채널을 예약)

### ③ 순번 기반 (Taking Turns)
* **폴링(Polling)**: 마스터 장비가 "보낼 사람?" 하고 물어보고 허가하는 중앙집중식 방식입니다. 
* **토큰 패싱(Token Passing)**: "전송 권한(토큰)"을 가진 노드만 전송하고, 다 보내면 토큰을 옆 노드에 넘기는 방식입니다. 

---

## 5. 🏠 LAN (Local Area Network)


이제 LAN 환경에서 L2의 핵심 구성요소인 MAC 주소, ARP, 스위치, VLAN을 알아봅니다.

### ① MAC 주소 (Media Access Control Address)

IP 주소가 L3(네트워크)의 '논리적 주소'라면, MAC 주소는 L2(링크)의 **'물리적 주소'**입니다. 

* **특징**:
    * 48비트(6바이트)의 16진수 주소입니다 (예: `00:1A:2B:3C:4D:5E`). 
    * NIC(랜카드)가 공장에서 생산될 때 하드웨어에 고정되어 나옵니다. 
    * 전 세계적으로 유일해야 합니다 (IEEE가 관리하며, 앞 24비트(OUI)로 제조사를 구분함). 
* **역할**: IP는 인터넷 전체의 경로를 찾는 데 사용되고, MAC은 **같은 LAN(서브넷) 내부**에서 "바로 다음 홉" 장치를 찾는 데 사용됩니다. 

> **핵심 비유: IP vs MAC** 
> * **IP 주소** = **우편 주소** (이사 가면 바뀜, 즉 네트워크에 따라 변경됨) 
> * **MAC 주소** = **주민등록번호** (태어날 때 받음, 하드웨어에 고정됨) 
>
> 편지를 보낼 때(라우팅)는 '우편 주소(IP)'를 보고 도시(네트워크)를 찾아가지만, 그 도시 안에서 실제 집(장치)에 배달할 때는 '주민번호(MAC)'를 확인하는 것과 같습니다. 

### ② ARP (Address Resolution Protocol)


네트워크 계층(L3)과 링크 계층(L2)을 이어주는 **핵심 다리** 역할을 하는 프로토콜입니다. 

* **문제 상황**: 내 PC(137.196.7.23)가 같은 LAN 내부의 다른 PC(137.196.7.14)에게 IP 데이터그램을 보내려 합니다. 나는 IP 주소는 알지만, 프레임을 만들려면 상대방의 **MAC 주소**가 필요합니다. 
* **ARP의 역할**: **"IP 주소 → MAC 주소"**로 변환(매핑)해 줍니다. 

#### ARP 동작 절차 

 

1.  **ARP Request (Broadcast)**:
    * Host A가 LAN 내의 **모든 노드**에게 브로드캐스트(목적지 MAC: `FF:FF:FF:FF:FF:FF`)로 외칩니다. 
    * "IP 주소 `137.196.7.14`를 가진 분, 당신의 MAC 주소는 무엇입니까?" 
2.  **ARP Reply (Unicast)**:
    * LAN의 모든 노드가 이 요청을 받지만, 자신의 IP와 일치하는 **Host B**만 응답합니다. 
    * Host B가 Host A에게 1:1 유니캐스트로 응답합니다. 
    * "그거 저입니다. 제 MAC 주소는 `58-23-D7-FA-20-B0`입니다." 
3.  **ARP Cache 저장**:
    * Host A는 이 응답을 받고 `(137.196.7.14 → 58-23-D7-FA-20-B0)` 매핑 정보를 자신의 **ARP 캐시(테이블)**에 저장합니다. 
    * 다음부터는 브로드캐스트 없이 캐시된 MAC 주소를 바로 사용합니다. 

### ③ 이더넷 (Ethernet)


현재 유선 LAN의 표준 기술(IEEE 802.3)입니다. 

* **이더넷 프레임 구조:** 
    * **Dest MAC (6B)**: 목적지 MAC 주소 
    * **Src MAC (6B)**: 출발지 MAC 주소 
    * **Type (2B)**: 상위 계층 프로토콜 식별자. (예: 0x0800 = IPv4, 0x0806 = ARP, 0x86DD = IPv6) 
    * **Payload (46~1500B)**: 실제 내용물 (IP 데이터그램 등) 
    * **CRC (4B, FCS)**: 오류 검출용 코드 
* **특징**:
    * **비연결형(Connectionless)**: 연결 설정 없이 바로 전송합니다. 
    * **비신뢰성(Unreliable)**: 오류 검출(CRC)은 하지만, 프레임이 손실되면 L2에서 **재전송하지 않고 폐기**합니다. 신뢰성은 상위 L4(TCP)가 담당합니다. 

### ④ 링크 계층 스위치 (Switch)


라우터(L3)가 IP 주소로 경로를 찾는다면, 스위치는 **MAC 주소**로 프레임을 전달하는 L2 장비입니다. 현대 LAN의 핵심입니다.

스위치는 **스스로 학습(Self-learning)**하는 기능을 가집니다. 

#### 스위치의 3가지 핵심 동작 

1.  **학습 (Learning)**: 프레임이 들어오면, **출발지(Source) MAC 주소**를 보고 "아, 이 MAC 주소는 이 포트에 연결되어 있구나"라고 **MAC 주소 테이블**에 자동으로 기록(학습)합니다. 
2.  **포워딩 (Forwarding)**: **목적지(Destination) MAC 주소**가 테이블에 있으면, 해당 포트로만 프레임을 1:1 전송합니다. 
3.  **플러딩 (Flooding)**: **목적지 MAC 주소**가 테이블에 *없으면* (처음 보거나 모를 때), 프레임을 수신한 포트를 제외한 **모든 포트**로 뿌립니다(브로드캐스트처럼). 
4.  (참고) **필터링 (Filtering)**: 목적지가 출발지와 같은 포트일 경우, 프레임을 버립니다. 

#### 스위치 학습 예시 

 

1.  (스위치 테이블은 비어있음) 
2.  **A(Port 1)가 A'(Port 4)에게** 프레임을 전송합니다. 
3.  **동작 ① (학습)**: 스위치는 **출발지 A**의 MAC을 보고 `{A, 1, 60}`을 테이블에 기록합니다. 
4.  **동작 ② (플러딩)**: 스위치는 **목적지 A'**를 테이블에서 찾지만, 없습니다. 
5.  스위치는 Port 1을 제외한 모든 포트(2, 3, 4, 5)로 프레임을 **플러딩**합니다. 
6.  A'가 응답 프레임(**A'가 A에게**)을 Port 4로 보냅니다. 
7.  **동작 ① (학습)**: 스위치는 **출발지 A'**를 보고 `{A', 4, 60}`을 테이블에 기록합니다. 
8.  **동작 ② (포워딩)**: 스위치는 **목적지 A**를 테이블에서 찾습니다. (Port 1에 있음)
9.  스위치는 이 프레임을 **오직 Port 1로만** 전송합니다. (더 이상 플러딩 안 함)

### ⑤ VLAN (Virtual LAN)


* **문제점**: 스위치 하나에 모든 장치를 연결하면, 하나의 거대한 브로드캐스트 도메인이 됩니다. ARP 요청 하나가 모든 PC에 전달되어 비효율적이고 보안에 취약합니다. 
* **VLAN의 정의**: 하나의 물리적 스위치를 **"논리적으로 여러 개의 격리된 스위치"**로 나누는 기술입니다. 
* **핵심 효과**:
    1.  **브로드캐스트 도메인 분리**: VLAN 10(예: 재무팀)의 브로드캐스트는 VLAN 20(예: 개발팀)에 절대 전달되지 않습니다. 
    2.  **보안 및 관리**: 물리적 위치와 상관없이 논리적으로 그룹을 분리하여 관리할 수 있습니다. 

#### VLAN 구현: 802.1Q 태깅


* VLAN을 구분하기 위해, 이더넷 프레임 내부에 **VLAN Tag(태그)**라는 꼬리표를 삽입합니다. 
* 이 태그 안에는 "이 프레임은 VLAN 10 소속임"을 알리는 **VLAN ID (12비트)**가 들어있습니다. 
* 이 표준을 **IEEE 802.1Q**라고 합니다. 

#### 트렁크 포트 (Trunk Port)

* **Access Port**: PC와 연결되는 일반 포트. 태그가 없는 프레임을 처리합니다.
* **Trunk Port**: **스위치와 스위치 사이**를 연결하는 포트입니다. 
* **역할**: VLAN 10, 20, 30 등 **여러 VLAN의 트래픽(태그가 붙은 프레임)**을 하나의 물리적 링크로 동시에 전송하는 통로입니다. 

---

## 6. 🛠️ 실습 (Cisco Packet Tracer)


Cisco Packet Tracer 시뮬레이터를 사용하여 링크 계층의 동작을 확인합니다. 

### 실습 1: ARP 동작 확인


1.  PC 2대(PC0: 192.168.1.10, PC1: 192.168.1.20)와 스위치 1대를 배치합니다. 
2.  PC0에서 PC1로 `ping 192.168.1.20`을 실행합니다. (Ping 성공) 
3.  PC0에서 `arp -a` 명령을 실행합니다.
4.  **결과**: Ping(ICMP)을 보내기 위해 먼저 ARP가 동작했기 때문에, PC0의 ARP 캐시에 PC1의 IP(`192.168.1.20`)와 MAC 주소(`0060.7036.87ae`)가 동적(dynamic)으로 매핑되어 저장된 것을 확인할 수 있습니다. 

### 실습 2: 스위치 MAC 주소 학습 (Self-learning)


1.  스위치의 CLI(명령줄 인터페이스)에 접속합니다. 
2.  `enable` (특권 모드 진입) → `show mac address-table` (MAC 테이블 확인) 
3.  **결과 (초기)**: 테이블이 비어있습니다. 
4.  PC A에서 PC B로 `ping`을 실행합니다 (ARP와 ICMP 발생). 
5.  다시 스위치에서 `show mac address-table`을 실행합니다.
6.  **결과 (핑 이후)**: 스위치가 PC A의 MAC(`00d0.58e1.e853`)을 `Fa0/1` 포트에서, PC B의 MAC(`0060.7036.87ae`)을 `Fa0/2` 포트에서 **DYNAMIC(동적)**으로 학습한 것을 보여줍니다. 

### 실습 3: VLAN 구성 (브로드캐스트 분리)


1.  4대의 PC를 스위치에 연결합니다.
2.  스위치 CLI에서 VLAN을 생성하고 포트를 할당합니다.
    * `configure terminal` (설정 모드) 
    * `interface range fastEthernet 0/1 - 2` (1~2번 포트 선택) 
    * `switchport mode access`
    * `switchport access vlan 10` (VLAN 10 할당) 
    * `interface range fastEthernet 0/3 - 4` (3~4번 포트 선택) 
    * `switchport access vlan 20` (VLAN 20 할당) 
3.  `show vlan brief`로 결과를 확인하면, VLAN 10과 20이 생성되고 포트가 할당된 것을 볼 수 있습니다. 
4.  **테스트**:
    * PC1(VLAN 10, `.1.10`)에서 PC2(VLAN 10, `.1.20`)로 Ping → **성공** 
    * PC1(VLAN 10, `.1.10`)에서 PC4(VLAN 20, `.2.20`)로 Ping → **실패 (Request timed out)** 
    * PC3(VLAN 20, `.2.10`)에서 PC4(VLAN 20, `.2.20`)로 Ping → **성공** 
5.  **결론**: VLAN 10과 VLAN 20은 논리적으로 완전히 분리되어 통신(브로드캐스트 포함)이 차단되었습니다.

### 실습 4: VLAN 트렁크 실습


1.  **상황**: 스위치 2대(SW1, SW2)를 연결. PC1(SW1 소속)과 PC2(SW2 소속)가 **서로 다른 스위치**에 있지만, **둘 다 VLAN 10**에 속하게 해야 합니다. 
2.  **Access 포트 설정**: SW1의 `fa0/1`(PC1 연결)과 SW2의 `fa0/2`(PC2 연결)를 각각 `switchport access vlan 10`으로 설정합니다. 
3.  **Trunk 포트 설정**: 스위치끼리 연결된 포트(예: `fa0/24`)를 트렁크 모드로 설정합니다. 
    * `interface fa0/24`
    * `switchport mode trunk` 
    * `switchport trunk allowed vlan 10,20` (VLAN 10, 20 태그가 붙은 프레임만 이 링크로 통과 허용) 
4.  **확인**: `show interfaces trunk` 명령으로 `Fa0/24` 포트가 `trunking` 상태이고, `802.1q` 캡슐화를 사용하며, VLAN 10, 20을 허용하는지 확인합니다. 
5.  **결과**: 트렁크 링크를 통해 두 스위치가 VLAN 10 정보를 공유하므로, PC1(SW1)과 PC2(SW2)가 통신할 수 있게 됩니다.

---

(페이지 48)
감사합니다.
