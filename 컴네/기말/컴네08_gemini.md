안녕하세요! 컴퓨터 네트워크 9주차 강의인 '네트워크 계층: 데이터 평면' PDF 파일의 전체 내용을 요청하셨네요.

이 자료는 네트워크의 핵심인 **라우터**가 어떻게 동작하는지, 그리고 IP 패킷이 어떤 원리로 경로를 찾아가는지에 대한 내용입니다. 사용자님은 컴퓨터 공학 전공자이시고[USER_CONTEXT] 특히 웹/DevOps에 관심이 많으시니[USER_CONTEXT], 이 내용은 인터넷 트래픽이 실제로 처리되는 '고속도로 교차로'의 내부 동작을 이해하는 데 필수적인 지식이 될 것입니다.

PDF의 모든 내용을 처음부터 끝까지, 빼먹는 내용 없이 술술 읽히도록 자세히 풀어서 설명해 드리겠습니다.

---

# 🖥️ 컴퓨터네트워크: 9주차 네트워크 계층 (데이터 평면)



이번 9주차 강의는 **네트워크 계층(Network Layer)**에 대해 다루며, 그중에서도 **데이터 평면(Data Plane)**에 집중합니다. 

### 🎯 이번 주 학습 목표

1.  네트워크 계층의 주요 기능(포워딩, 라우팅)을 이해합니다. 
2.  **데이터 평면**과 **제어 평면**의 차이를 명확히 구분합니다. 
3.  라우터의 내부 구조와 동작 방식을 설명할 수 있습니다. 
4.  IP 프로토콜, NAT, IPv6의 역할을 이해합니다. 

---

## 1. 🌐 네트워크 계층이란?

네트워크 계층(L3)은 인터넷의 핵심 계층으로, 출발지 호스트에서 목적지 호스트까지 패킷을 전달하는 역할을 합니다. 

* **송신 측 (Sender)**:
    * 상위 계층인 전송 계층(L4)에서 받은 **세그먼트(Segment)**에 IP 헤더를 붙여 **데이터그램(Datagram)**으로 캡슐화합니다. 
    * 이 데이터그램을 하위 계층인 링크 계층(L2)으로 전달합니다. 
* **수신 측 (Receiver)**:
    * 링크 계층에서 받은 데이터그램의 헤더를 제거하고, 내부의 세그먼트를 상위 전송 계층(TCP/UDP)으로 전달합니다. 
* **라우터 (Router)의 역할**:
    * 라우터는 네트워크 계층에서 동작하는 핵심 장비입니다. 
    * 라우터는 자신을 지나가는 모든 IP 데이터그램의 **헤더를 검사**합니다. 
    * 패킷을 적절한 입력 포트에서 출력 포트로 전달(포워딩)하여, 패킷이 최종 목적지까지 올바른 경로로 이동하도록 합니다. 

 

---

## 2. 🚦 네트워크 계층의 두 가지 핵심 기능

네트워크 계층은 크게 두 가지 핵심 기능으로 나뉩니다. 

* **① 포워딩 (Forwarding)**: **"라우터 내부"**에서 일어나는 일입니다.
    * 패킷이 라우터의 입력 포트에 도착했을 때, 헤더 정보를 보고 "이 패킷을 몇 번 출력 포트로 내보내야 하는지" 결정하고 **즉시 이동**시키는 동작입니다. 
* **② 라우팅 (Routing)**: **"네트워크 전체"**의 관점에서 일어나는 일입니다.
    * 출발지에서 목적지까지 가는 **전체 경로(Path)를 결정**하는 과정입니다. 
    * "포워딩"을 제대로 하기 위한 '지도(포워딩 테이블)'를 만드는 과정입니다.

 
> **비유**:
> * **포워딩(Forwarding)**은 고속도로 교차로(라우터)에서 표지판을 보고 '부산' 방향 출구로 빠져나가는 **순간적인 동작**입니다.
> * **라우팅(Routing)**은 출발 전, '서울'에서 '부산'까지 가는 전체 최적 경로(경부고속도로)를 계산하는 **계획 과정**입니다.

---

## 3. ✈️ 데이터 평면 vs 제어 평면

네트워크 계층의 두 기능을 다시 두 개의 "평면(Plane)"으로 분리해서 부릅니다. 

### 데이터 평면 (Data Plane)

* **역할**: **포워딩(Forwarding)**을 담당합니다. 
* **특징**:
    * **라우터 내부(Local)**에서 수행됩니다. 
    * 들어오는 패킷의 헤더를 보고, 미리 계산된 '포워딩 테이블'을 참조하여 패킷을 고속으로 전달합니다. 
    * **하드웨어** 기반으로 동작하며, 나노초(nanosecond) 단위의 매우 빠른 속도가 필요합니다. 

### 제어 평면 (Control Plane)

* **역할**: **라우팅(Routing)**을 담당합니다. 
* **특징**:
    * **네트워크 전체(Global)** 관점에서 동작합니다. 
    * 라우팅 알고리즘(예: OSPF, BGP)을 실행하여, 데이터 평면이 사용할 '포워딩 테이블'을 **계산하고 만듭니다.** 
    * **소프트웨어** 기반으로 동작하며, 밀리초(millisecond) 단위로 비교적 느리게 동작합니다. 

 

---

## 4. 🧠 제어 평면의 두 가지 방식

이 "지도(포워딩 테이블)"를 만드는 방식(제어 평면)에는 두 가지 접근법이 있습니다.

### ① 전통적 방식: 라우터 기반 제어 (분산형)


* **개념**: **모든 라우터가 각자 똑똑합니다.** 
* **동작**: 각 라우터가 **개별적으로** 라우팅 알고리즘을 실행합니다. 
* 이웃 라우터들과 서로 정보를 교환("저기 가는 데 5초 걸려", "아니야, 이쪽이 3초야")하며 스스로 최적의 경로를 계산하고 포워딩 테이블을 만듭니다. 
* **대표 프로토콜**: **RIP**, **OSPF** (내부용), **BGP** (외부용) 

#### 📜 대표적인 라우팅 프로토콜 (전통 방식)

* **RIP (Routing Information Protocol)** 
    * **방식**: 거리 벡터 (Distance Vector) 
    * **특징**: 이웃 라우터의 정보("A까지 2홉")만 듣고 경로를 계산합니다. 
    * **척도(Metric)**: 오직 **홉 수(Hop count)**, 즉 몇 개의 라우터를 거치는지로만 경로를 계산합니다. (최대 15홉) 
    * **단점**: 30초마다 전체 테이블을 전송하여 비효율적입니다. 

* **OSPF (Open Shortest Path First)** 
    * **방식**: 링크 상태 (Link State) 
    * **특징**: **네트워크 전체 지도**를 공유합니다. (RIP보다 훨씬 효율적) 
    * **알고리즘**: 다익스트라(Dijkstra) 알고리즘으로 최단 경로를 계산합니다. 
    * **척도(Metric)**: 링크 비용(Cost) (주로 **대역폭**을 반영하여 100Mbps보다 1Gbps 도로를 선호함) 

* **BGP (Border Gateway Protocol)** 
    * **방식**: 경로 벡터 (Path Vector) 
    * **특징**: 인터넷 그 자체. **ISP(통신사)** 간의 라우팅에 사용됩니다. 
    * **척도(Metric)**: 단순 비용이 아닌, AS(자율 시스템) 경로, 정책 등 복잡한 속성을 기반으로 경로를 결정합니다. 

### ② 현대적 방식: SDN (중앙 집중형)


* **개념**: **라우터는 단순하게 만들고, 중앙 컨트롤러가 모든 두뇌 역할을 합니다.** 
* **동작**:
    * **Remote Controller (SDN 컨트롤러)**라는 중앙 서버가 네트워크 전체의 상황을 파악하고 모든 경로를 계산합니다. 
    * 각 라우터는 컨트롤러로부터 "이런 패킷 오면 2번 출구로 보내"라는 **지시(포워딩 테이블)**를 받아, **단순히 전달만** 합니다. 
* **장점**: 네트워크 관리 및 업데이트가 중앙 집중형이라 매우 효율적입니다. 

---

## 5. 📦 네트워크 서비스 모델

네트워크 계층이 "어떤 품질"의 서비스를 제공해야 할까요? 

* **보장형 서비스 (Guaranteed Service)**: 
    * "40ms 이하의 지연 보장" 또는 "최소 대역폭 보장" 
    * 예: **ATM** 기술은 일정한 속도(CBR)나 최소 대역폭(ABR)을 보장해 줍니다. 
* **최선형 서비스 (Best-effort Service)**: 
    * **인터넷**이 사용하는 방식입니다. 
    * **아무것도 보장하지 않습니다.** 
    * 패킷 도착 보장 (X) 
    * 도착 순서나 타이밍 보장 (X) 
    * 특정 대역폭 확보 (X) 

### 🤔 Best-effort가 성공한 이유

아무것도 보장하지 않는 "최선형" 모델이 어떻게 성공했을까요? 

1.  **단순함**: 구조가 단순해서 전 세계적으로 쉽고 빠르게 채택되었습니다. 
2.  **충분한 대역폭 (Over-provisioning)**: 기술 발전으로 대역폭이 "충분히" 확보되면서, 실시간 영상/음성 서비스도 "대부분의 시간엔" 문제없이 동작하게 되었습니다. 
3.  **애플리케이션의 진화**: CDN 등을 통해 사용자와 가까운 곳에서 서비스를 제공하고, TCP 혼잡 제어(L4)나 DASH(L7) 같은 상위 계층 기술이 네트워크의 불완전함을 보완해 줍니다. 

**결론**: "Best-effort 모델의 성공을 부정하기 어렵다." 

---

## 6. 🛠️ 라우터 내부 구조 (데이터 평면)

이제부터는 '포워딩'을 담당하는 **데이터 평면**의 내부를 자세히 봅니다. 
라우터는 크게 4개의 구성 요소로 이루어집니다. 

1.  **입력 포트 (Input Ports)** 
2.  **스위칭 패브릭 (Switching Fabric)** 
3.  **출력 포트 (Output Ports)** 
4.  (제어 평면의) **라우팅 프로세서 (Routing Processor)** 

 

### ① 입력 포트 (Input Port)

 
패킷이 라우터에 들어오는 첫 번째 관문입니다. 

* **동작 순서**:
    1.  **라인 종단 (Line Termination)**: 물리 계층. 케이블에서 전기 신호(비트)를 받습니다. 
    2.  **링크 계층 처리 (Data Link Processing)**: 링크 계층. 이더넷 헤더 등을 제거(Decapsulation)합니다. 
    3.  **조회, 포워딩, 큐잉 (Lookup, Forwarding, Queuing)**: **데이터 평면의 핵심.** 
        * 패킷 헤더(목적지 IP)를 보고 포워딩 테이블을 **조회(Lookup)**합니다. 
        * "이 패킷은 3번 출력 포트로 가야 한다"고 결정합니다.
        * 스위칭 패브릭이 바쁘면 잠시 **입력 큐(Queue)**에 대기합니다. 

* **분산 스위칭**: 요즘 라우터는 CPU(라우팅 프로세서)까지 물어보지 않고, 각 입력 포트가 자체적으로 포워딩 테이블을 가져 **독립적으로(분산형)** 포워딩 결정을 수행합니다. 

#### 🔍 포워딩 테이블 조회: 최장 접두어 매칭 (LPM)

라우터는 포워딩 테이블을 조회할 때 **최장 접두어 매칭(Longest Prefix Matching)** 규칙을 따릅니다. 

* **개념**: 하나의 목적지 IP 주소가 테이블의 여러 항목과 일치할 경우, **가장 구체적인(접두어가 가장 긴) 항목**을 선택합니다. 
* **예시**:
    * 목적지 IP: `11001000 ... 0001 1000 ...` 
    * 규칙 1: `11001000 ... 00010***` → 포트 0 (21비트 일치) 
    * 규칙 2: `11001000 ... 00011***` → 포트 1 (22비트 일치) 
    * **선택**: 규칙 2 (포트 1)가 더 길게(더 구체적으로) 일치하므로, 패킷은 **포트 1**로 전송됩니다. 
* **TCAM (Ternary Content Addressable Memory)**: 이 LPM 조회를 하드웨어적으로 매우 빠르게(1 클록) 처리하기 위한 특수 메모리입니다. 

### ② 스위칭 패브릭 (Switching Fabric)

 
라우터의 "중추 신경"으로, 패킷을 입력 포트에서 출력 포트로 **실제로 전달하는 내부 경로**입니다. 

* **스위칭 속도(Rate)**: N개의 포트가 각각 R의 속도를 가질 때, 이상적인 패브릭 속도는 **N x R** 입니다. 
* **3가지 구현 방식**: 
    1.  **메모리 기반 (1세대)**: 입력 포트 → CPU 메모리 → 출력 포트. 메모리 대역폭이 병목이 되어 속도가 느립니다. 
    2.  **버스 기반 (저가형)**: 모든 포트가 하나의 **공유 버스**를 통해 통신. 버스를 차지하려는 경합(Contention)이 발생하며 속도 한계가 명확합니다. 
    3.  **상호연결망 (고성능)**: Crossbar(격자형)나 다단계 스위치망을 사용. 여러 패킷이 동시에 **병렬 처리**가 가능해 속도가 매우 빠르고 확장성이 좋습니다. 고성능 코어 라우터(예: Cisco CRS)에서 사용됩니다. 

### ③ 출력 포트 (Output Port)

 
패킷이 라우터를 떠나는 마지막 관문입니다. 

* **동작 순서**:
    1.  **큐잉 (Queuing)**: 스위칭 패브릭에서 온 패킷을 **출력 버퍼**에 저장합니다. (패킷 스케줄링을 위해 대기)
    2.  **링크 계층 처리 (Data Link Processing)**: 이더넷 헤더 등을 다시 포장(Encapsulation)합니다. 
    3.  **라인 종단 (Line Termination)**: 물리 계층. 패킷을 전기 신호(비트)로 변환하여 케이블로 송신합니다. 

---

## 7. 🤯 라우터의 큐잉과 혼잡 문제

패킷은 라우터의 **입력 포트**와 **출력 포트** 양쪽에서 큐(줄)를 서게 되며, 여기서 혼잡과 손실이 발생합니다.

### 입력 포트 큐잉: HOL 블로킹

 
* **상황**: 여러 입력 포트의 패킷(빨강, 파랑, 초록)이 **동시에 같은 출력 포트(빨강)**로 가려고 할 때 발생합니다. (출력 포트 경합) 
* **HOL (Head-of-the-Line) 블로킹**:
    * 큐의 **맨 앞(Head)**에 있던 빨간색 패킷이 출력 포트 경합 때문에 대기하게 됩니다. 
    * **문제**: 이 빨간 패킷 때문에, 그 뒤에 있던 **초록색 패킷(다른 출력 포트로 가야 함)**도 아무 상관 없이 덩달아 대기하는 현상이 발생합니다. 

### 출력 포트 큐잉 (주요 혼잡 지점)

 
* **상황**: 스위칭 패브릭의 속도가 출력 링크의 속도보다 빠를 때 발생합니다. (예: 여러 개의 10Gbps 입력 포트에서 온 패킷이 하나의 1Gbps 출력 링크로 몰릴 때)
* **결과**: 패킷이 출력 포트 버퍼에 쌓이게 되고, 이 버퍼가 꽉 차면 **패킷 손실(Drop)**이 발생합니다. (이것이 TCP 혼잡 제어가 감지하는 '혼잡'입니다.)
* **버퍼 관리**:
    * **드롭 정책 (Drop Policy)**: 버퍼가 꽉 찼을 때 어떤 패킷을 버릴지 결정합니다. 
        * `Tail Drop` (꼬리 자르기): 가장 최근에 도착한 패킷을 버립니다. (가장 단순함) 
        * `Priority Drop` (우선순위): 중요도 낮은 패킷(예: 파일 다운로드)을 먼저 버립니다. 
    * **마킹 (Marking)**: 패킷을 버리는 대신, 헤더에 "지금 혼잡해!"라는 표시(ECN)를 남겨 송신자에게 경고합니다. 

### 📏 버퍼는 얼마나 커야 할까?

* **전통적 방식**: `버퍼 = RTT x 링크 속도(C)` . (10Gbps 링크, RTT 250ms면 2.5Gbit 버퍼 필요) 
* **현대적 방식**: `버퍼 = (RTT x C) / √N` (N = 동시에 흐르는 플로우 수) . TCP 플로우가 많아지면 버퍼가 더 작아도 됩니다.
* **Bufferbloat 문제**: 버퍼가 *너무 크면* 패킷 손실은 없지만, 큐에 머무는 시간이 길어져 **지연(Delay)이 오히려 급증**하는 문제가 발생합니다. 

### 🚦 패킷 스케줄링 (전송 순서 결정)

출력 포트 큐에 쌓인 패킷들을 어떤 순서로 내보낼지 결정하는 정책입니다. 

1.  **FCFS (First Come, First Served)**
    * **"선착순"**입니다. 
    * 구현이 가장 단순하지만 , 특정 트래픽(예: 토렌트)이 큐를 독점하면 다른 중요한 트래픽(예: 게임)이 지연(기아)될 수 있습니다. 
2.  **Priority Queuing (우선순위 큐잉)**
    * "VIP 먼저"입니다. 트래픽을 분류(classify)하여 중요도(High/Low)에 따라 큐를 나눕니다. 
    * **항상 높은 우선순위 큐(예: 음성 통화)**를 먼저 처리합니다. 
    * 낮은 우선순위 큐(예: 이메일)는 지연될 수 있습니다. 
3.  **Round Robin (RR) / WFQ (가중 공평 큐잉)**
    * "공평하게 돌아가면서"입니다. 
    * **RR**: 각 큐(Flow A, B, C)에서 하나씩 번갈아 가며 전송합니다. 
    * **WFQ (Weighted Fair Queuing)**: RR의 발전형. 큐마다 **가중치(Weight)**를 둡니다. (예: A는 50%, B는 30%, C는 20% 비율로 전송) QoS 제어에 효과적입니다. 

---

## 8. 📝 실습 (Python 시뮬레이션)

(페이지 48-56)
Python의 `networkx` 라이브러리를 사용해 제어 평면과 데이터 평면의 동작을 시뮬레이션합니다.

* **실습 1: 토폴로지 시각화**
    * 5개의 라우터(R1~R5)와 각 링크의 비용(가중치)을 정의하여 네트워크 토폴로지(지도)를 그립니다. 

* **실습 2: 제어 평면 - Link-State (Dijkstra)**
    * OSPF와 같은 **링크 상태** 알고리즘을 시뮬레이션합니다. 
    * `nx.single_source_dijkstra_path_length` 함수를 사용해, 각 라우터가 "전체 지도"를 기반으로 다른 모든 노드까지의 최단 거리를 계산한 테이블을 만듭니다. 
    * (예: R1 테이블 → R5까지의 최단 거리는 6) 

* **실습 3: 제어 평면 - Distance-Vector (Bellman-Ford)**
    * RIP와 같은 **거리 벡터** 알고리즘을 시뮬레이션합니다. 
    * 라우터가 이웃의 정보만 교환하는 것을 반복(iterations)하여 , 최종적으로 최단 거리 테이블을 완성합니다. 
    * (결과는 당연히 실습 2의 Link-State와 동일하게 나옵니다.) 

* **실습 4: 데이터 평면 - 패킷 전송 시뮬레이션**
    * 제어 평면(실습 2)이 만든 테이블을 기반으로, 데이터 평면이 **실제 포워딩**하는 과정을 흉내 냅니다. 
    * **R1 → R5 패킷 전송**: `nx.shortest_path` 함수로 최단 경로를 찾습니다. 
    * **경로**: R1 → R2 → R4 → R5 
    * (R1→R3은 비용이 5지만, R1→R2→R4→R5는 (2+3+1)=6, R1→R2→R3→R4→R5는 (2+1+2+1)=6, R1→R3→R4→R5는 (5+2+1)=8... *[강의 자료 계산 오류]*
    * *[정정]* `R1→R3` (비용 5)보다 `R1→R2→R3` (비용 2+1=3)이 더 빠르므로, R1의 R3 경로는 3입니다. 
    * *[정정]* 따라서 R1→R5의 최단 경로는 `R1→R2→R3→R4→R5` (비용 2+1+2+1 = 6) 또는 `R1→R2→R4→R5` (비용 2+3+1=6)입니다. 시뮬레이션은 `['R1', 'R2', 'R4', 'R5']`를 선택했습니다. 

* **실습 5: 중앙 제어 (SDN) 시뮬레이션**
    * **SDN 컨트롤러**가 R1을 기준으로 모든 노드까지의 경로를 **중앙에서 계산**하는 것을 시뮬레이션합니다. 
    * 컨트롤러는 이 경로(`['R1', 'R2', 'R4', 'R5']`)를 계산한 뒤, 각 라우터(R1, R2, R4)에 포워딩 규칙을 내려보냅니다.

* **실습 6: 네트워크 장애 실험**
    * `R2`와 `R3` 사이의 링크가 **단절(장애)**되는 상황을 가정합니다. 
    * 제어 평면(Link-State)이 즉시 이 장애를 인지하고 **새로운 최단 경로**를 다시 계산합니다. 
    * R1 → R5로 패킷을 다시 전송합니다. 
    * **결과**: 장애가 발생했지만, 제어 평면이 경로를 재계산(`R1→R2→R4→R5` 경로는 R2-R3과 무관하므로 여전히 유효)하여 데이터 평면은 **중단 없이** 패킷을 R5에 도착시킵니다. 

---

(페이지 56)
감사합니다.
