안녕하세요! 컴퓨터 네트워크 6주차 강의인 'TCP/UDP 비교 및 혼잡 제어' PDF 파일의 전체 내용을 요청하셨습니다.

이 자료는 전송 계층의 "꽃"이라고 할 수 있는 **신뢰성(RDT)**과 **혼잡 제어(Congestion Control)**를 다룹니다. 사용자님은 컴퓨터 공학을 전공하고[USER_CONTEXT] 웹/DevOps에 관심이 많으시니[USER_CONTEXT], 이 내용은 네트워크 성능을 좌우하는 TCP의 핵심 동작 원리를 이해하는 데 가장 중요한 부분입니다.

PDF의 모든 내용을 논리적인 흐름에 따라 처음부터 끝까지, 빠짐없이 쉽게 풀어서 설명해 드리겠습니다.

---

# 🖥️ 컴퓨터네트워크: 6주차 TCP/UDP 비교 (혼잡 제어)



이번 6주차 강의는 **전송 계층(Transport Layer)**의 핵심 프로토콜인 **UDP**와 **TCP**, 그리고 TCP의 가장 중요한 기능인 **혼잡 제어(Congestion Control)**에 대해 자세히 다룹니다. 

### 🎯 이번 주 학습 목표

1.  **다중화/역다중화**: 여러 앱이 하나의 인터넷 연결을 공유하는 방법 
2.  **신뢰적 데이터 전송 (RDT)**: TCP가 어떻게 데이터 손실을 극복하는지에 대한 이론 
3.  **TCP**: RDT, 흐름 제어, 혼잡 제어를 구현한 프로토콜 
4.  **UDP**: RDT가 없는 단순한 프로토콜 
5.  **흐름 제어**: 송신자와 **수신자** 간의 속도 조절 
6.  **혼잡 제어**: 송신자와 **네트워크** 간의 속도 조절 

---

## 1. 🚦 전송 계층의 4가지 핵심 원리

전송 계층은 애플리케이션(응용 계층)과 네트워크(IP 계층) 사이의 논리적 연결을 담당합니다. 이 계층의 4가지 핵심 기능을 이해해야 합니다.

### ① 다중화 (Multiplexing) / 역다중화 (Demultiplexing)

* **다중화 (송신측)**: 여러 개의 데이터(예: 웹, 메일, FTP)를 하나의 통신 채널(IP 패킷)로 합치는 과정입니다. 
* **역다중화 (수신측)**: 하나의 채널로 들어온 데이터를 보고, "이건 웹 서버로, 저건 메일 서버로"처럼 각 수신자(프로세스)에게 정확히 나누어주는 과정입니다. 

### ② 신뢰적 데이터 전송 (RDT)

* 네트워크는 완벽하지 않아 패킷 손실, 오류, 순서 뒤바뀜이 발생합니다.
* **TCP**: 순서 제어, ACK(응답), 재전송을 통해 이 모든 문제를 해결하고 신뢰성 있는 데이터 전송을 보장합니다. 
* **UDP**: 신뢰성을 보장하지 않습니다 (오류 검출을 위한 최소한의 체크섬만 제공). 

### ③ 흐름 제어 (Flow Control)

* **문제**: 송신자가 너무 빨리 보내서 수신자의 처리 속도를 넘어설 때 발생합니다. (수신자 버퍼 오버플로) 
* **기능**: **수신자 중심** 제어입니다. 수신자가 "나 지금 이만큼만 더 받을 수 있어"라고 자신의 버퍼 상태(`rwnd`, Receive Window)를 알려주며 송신 속도를 조절합니다. 

### ④ 혼잡 제어 (Congestion Control)

* **문제**: 송신자들이 "네트워크 전체"가 감당할 수 없을 만큼 많은 데이터를 보낼 때 발생합니다. (라우터 마비, 패킷 손실) 
* **기능**: **네트워크 중심** 제어입니다. TCP는 패킷 손실이나 지연을 "혼잡의 신호"로 감지하고, 스스로 전송 속도(`cwnd`, Congestion Window)를 조절합니다. 
* **핵심 알고리즘**: TCP는 4단계(느린 시작, 혼잡 회피, 혼잡 발생, 빠른 회복)를 통해 속도를 조절합니다. 

---

## 2. 📮 다중화/역다중화 상세


여러 애플리케이션(스카이프, 넷플릭스)이 하나의 전송 계층(Transport)을 통해 데이터를 보내고 받는 원리입니다. 

* **송신측 (다중화)**: 여러 소켓(프로세스)의 데이터를 모아 전송 계층 헤더(포트 번호)를 붙여서 보냅니다. 
* **수신측 (역다중화)**: 수신된 세그먼트의 헤더 정보(포트 번호)를 보고 올바른 소켓(프로세스)으로 데이터를 전달합니다. 

### 계층별 다중화 비교

다중화는 사실 모든 네트워크 계층에서 일어납니다.

| 계층 | 다중화 방식 | 설명 | 예시 |
| :--- | :--- | :--- | :--- |
| **L1 (물리)** | **신호 다중화** | 하나의 물리적 케이블을 여러 신호가 공유 | FDM (주파수 분할), TDM (시간 분할) |
| **L2 (링크)** | **프레임 다중화** | 하나의 링크 위에서 여러 논리 네트워크 구분 | VLAN Tagging |
| **L3 (네트워크)** | **패킷 다중화** | 하나의 경로로 TCP, UDP, ICMP 등 여러 프로토콜 전달 | IP 프로토콜 번호 (TCP=6, UDP=17) |
| **L4 (전송)** | **세그먼트 다중화** | **하나의 IP**에서 여러 앱을 구분 (핵심) | **TCP/UDP 포트 번호** (HTTP=80, SMTP=25) |
| **L7 (응용)** | **세션 다중화** | 하나의 앱(연결)에서 여러 요청을 병렬 처리 | HTTP/2의 Stream 다중화 |

### 🔍 TCP vs UDP 역다중화 (매우 중요)


수신측이 패킷을 받고 "이거 누구 거지?"라고 구분하는 방식이 다릅니다.

* **UDP (단순함)**
    * 오직 **"목적지 포트 번호"**만을 이용하여 역다중화합니다. 
    * 예: 53번 포트로 온 패킷은 무조건 DNS 프로세스에게 전달합니다. 
    * (단점: 출발지가 다른 2개의 패킷이 같은 53번 포트로 오면, UDP 수준에서는 구분이 안 됩니다.) 

* **TCP (정교함)**
    * **4-tuple (4개 정보)**을 모두 이용하여 역다중화합니다. 
        1.  출발지 IP
        2.  출발지 포트
        3.  목적지 IP
        4.  목적지 포트
    * TCP는 연결 지향형이므로, 이 4가지 정보가 모두 일치해야 "하나의 연결"로 식별합니다. 
    * **장점**: 수많은 클라이언트가 **동일한 목적지 포트(예: 80번)**로 접속해도, 출발지 IP와 포트가 모두 다르기 때문에 서버는 각 연결을 완벽하게 개별적으로 구분하고 관리할 수 있습니다. 

---

## 3. 🛡️ 신뢰적 데이터 전송 (RDT) 원리

RDT는 "신뢰할 수 없는 네트워크" 위에서 "신뢰할 수 있는 데이터"를 전송하는 기술의 총칭이며, **TCP의 근본 원리**입니다. 

### RDT 핵심 구성 요소 

| 요소 | 설명 |
| :--- | :--- |
| **ACK** | "잘 받았어"라는 긍정 확인 신호 |
| **NAK** | "오류 났어, 다시 보내"라는 부정 확인 신호 |
| **Timeout** | 정해진 시간 동안 ACK가 안 오면 '손실'로 판단하고 재전송 |
| **Sequence Number** | 패킷에 번호를 매겨 '중복'과 '순서'를 확인 |
| **Checksum** | 데이터의 비트 오류 검출 |
| **ARQ** | 이 모든 것을 조합한 자동 재전송 요청 방식 |

### RDT 프로토콜의 발전 단계 

1.  **RDT 1.0 (가장 이상적, 비현실적)**
    * 가정: 네트워크가 완벽하다 (오류X, 손실X) 
    * 동작: 그냥 보내고 받는다. (ACK, 재전송 불필요) 

2.  **RDT 2.0 (오류는 있지만, 손실은 없음)**
    * 가정: 비트 오류는 발생할 수 있다. 
    * 추가된 기능: Checksum, **ACK / NAK** 
    * 동작: 수신자가 Checksum으로 오류 검사 후, OK면 ACK, 오류면 NAK를 보냄. 송신자는 NAK를 받으면 재전송. 

3.  **RDT 2.1/2.2 (ACK/NAK도 손상될 수 있음)**
    * 가정: ACK/NAK 응답 패킷도 손상될 수 있다. 
    * 추가된 기능: **시퀀스 번호 (Sequence Number)** 
    * 동작: 송신자는 패킷 0번을 보냄. 수신자는 ACK 0번 응답. 송신자가 다음 1번을 보냈는데, 수신자가 1번을 받고 보낸 ACK 1번이 손상됨. 송신자는 응답을 못 받아 1번을 *재전송*. 수신자는 "어? 1번 아까 받았는데?" (시퀀스 번호로 확인) → 중복 패킷임을 알고 버림. 

4.  **RDT 3.0 (오류 + 손실 모두 고려, "Stop-and-Wait")**
    * 가정: 패킷(데이터, ACK)이 아예 **손실**될 수 있다. 
    * 추가된 기능: **Timeout (타임아웃)** 
    * 동작: 송신자는 패킷을 보낸 뒤 타이머를 켠다. 시간 내에 ACK가 도착하면 타이머 끄고 다음 패킷 전송. 만약 **Timeout**이 발생하면, "아, 패킷이 손실됐구나"라고 판단하고 **재전송**한다. 
    * **문제점 (Stop-and-Wait)**: 1개 보내고 1개 ACK 받을 때까지 *멍하니 기다려야 함*. 네트워크 RTT(왕복 시간)가 길면 매우 비효율적. 

### 파이프라인 전송 프로토콜 (RDT 3.0 개선)

Stop-and-Wait의 비효율을 해결하기 위해, "ACK를 기다리지 않고 여러 패킷을 동시에 전송하는" **파이프라인 방식**이 등장했습니다. (TCP의 핵심 모델) 

* **Go-Back-N (GBN)**
    * 송신자는 윈도우(N) 크기만큼(예: 4개) 패킷을 연속 전송 (0, 1, 2, 3). 
    * 수신자는 순서대로만 받습니다. (ACK는 '누적 ACK' 사용) 
    * **문제**: 만약 패킷 2번이 손실되면 , 수신자는 3번이 도착해도 "난 2번 아니면 안 받아"라며 3번을 **버립니다**. 
    * **결과**: 송신자는 패킷 2번의 Timeout이 발생하면, 손실된 2번부터 윈도우 끝까지 **(2, 3, 4, 5)를 전부 재전송**합니다. (비효율적)

* **Selective Repeat (SR) (선택적 재전송)**
    * 송신자는 윈도우(N) 크기만큼 패킷을 연속 전송 (0, 1, 2, 3). 
    * 수신자는 '개별 ACK'를 사용하며 , 순서가 뒤죽박죽 와도 **일단 버퍼에 저장**합니다. 
    * **상황**: 패킷 2번이 손실되고 , 3번이 도착. 수신자는 "3번 잘 받음" (ACK 3) 응답 후 3번을 **버퍼에 저장**. 
    * **결과**: 송신자는 패킷 2번의 Timeout이 발생하면, **오직 2번 패킷 "하나만" 재전송**합니다. 
    * 수신자는 2번을 받으면, 버퍼에 있던 3, 4, 5번과 합쳐서 상위 계층으로 전달합니다. (가장 효율적이지만 구현이 복잡함) 

> **TCP는?** TCP는 GBN과 SR을 섞은 하이브리드 방식입니다. [cite_start]기본적으로 GBN의 '누적 ACK'를 쓰지만, SR처럼 '선택적 재전송(SACK)' [cite: 374] 옵션을 사용하고 '빠른 재전송' 기능으로 SR과 유사하게 동작합니다. 

---

## 4. 🚚 TCP (Transmission Control Protocol) 상세

TCP는 RDT(신뢰성), 흐름 제어, 혼잡 제어를 모두 구현한 전송 계층의 핵심 프로토콜입니다. 

### TCP 세그먼트 구조 (헤더)

 

TCP가 모든 복잡한 기능을 수행할 수 있는 이유는 이 헤더 안에 모든 정보가 담겨있기 때문입니다.

| 구분 | 필드 이름 | 설명 |
| :--- | :--- | :--- |
| **포트** | Source Port (16bit) | 송신자(클라이언트) 포트 |
| **정보** | Destination Port (16bit) | 수신자(서버) 포트 |
| **전송 순서** | **Sequence Number** (32bit) | 송신 데이터의 순서 번호 (바이트 기준). RDT의 핵심. |
| **수신 확인** | **Acknowledgment Number** (32bit) | "다음엔 이 번호 줘" (즉, 이전까지 잘 받았다는 누적 ACK). RDT의 핵심. |
| **제어 정보** | Data Offset (4bit) | TCP 헤더의 전체 길이 (데이터 시작 위치) |
| **제어 비트** | **Flags (6~9bit)** | TCP의 상태를 제어하는 깃발 (가장 중요) |
| **흐름 제어** | **Window Size** (16bit) | "내가 더 받을 수 있는 버퍼 크기" (`rwnd`). **흐름 제어**용. |
| **오류 검출** | Checksum (16bit) | 헤더와 데이터의 오류 검출 |
| 기타 | Urgent Pointer, Options... | 긴급 데이터 위치, MSS/SACK 등 확장 옵션 |
| **데이터** | Data (가변) | 실제 애플리케이션 데이터 (예: HTTP) |

#### 🚩 TCP 제어 비트 (Flags) 

* `URG`: 긴급 데이터 
* **`ACK`**: Acknowledgment 번호가 유효함을 알림 (연결 수립 후 거의 모든 패킷에 포함) 
* `PSH`: "수신자는 버퍼에 쌓아두지 말고 즉시 앱으로 올려보내라" 
* **`RST`**: 연결 강제 초기화 (비정상 종료) 
* **`SYN`**: **연결 설정 요청**. (3-Way Handshake 1, 2단계) 
* **`FIN`**: **연결 종료 요청**. (4-Way Handshake) 

### TCP 연결 관리 (State Diagram)

TCP는 '상태'를 관리하며 연결을 제어합니다. 
(주요 상태: `LISTEN`, `SYN_SENT`, `SYN_RCVD`, `ESTABLISHED`, `FIN_WAIT`, `CLOSE_WAIT`, `TIME_WAIT`) 

#### 1. 연결 설정 (3-Way Handshake) 

1.  **[SYN]** Client → Server: "연결 요청할게" (Flag: `SYN`) 
2.  **[SYN+ACK]** Server → Client: "알겠어. 나도 연결 요청할게" (Flags: `SYN`, `ACK`) 
3.  **[ACK]** Client → Server: "알겠어" (Flag: `ACK`) 
    * → 양방향 `ESTABLISHED` (데이터 전송) 상태 돌입 

#### 2. 연결 종료 (4-Way Handshake) 

1.  **[FIN]** Client → Server: "나 이제 보낼 데이터 없어" (Flag: `FIN`) 
2.  **[ACK]** Server → Client: "알겠어. 네가 보낸 FIN 잘 받았어." (Flag: `ACK`) 
    * (이때 서버는 `CLOSE_WAIT` 상태가 되고 , 클라이언트는 `FIN-WAIT-2` 상태가 됨 )
    * (서버는 아직 보낼 데이터가 남아있으면 마저 보냄) 
3.  **[FIN]** Server → Client: "나도 이제 보낼 데이터 다 보냈어" (Flag: `FIN`) 
4.  **[ACK]** Client → Server: "알겠어. 네 FIN도 잘 받았어." (Flag: `ACK`) 
    * → 서버는 `CLOSED` (즉시 종료). 
    * → 클라이언트는 `TIME_WAIT` 상태로 일정 시간(2MSL) 대기 후 , `CLOSED` (지연 종료).

---

## 5. 🌊 TCP 흐름 제어 (Flow Control)


**"수신자 버퍼"** 오버플로를 방지하는 기능입니다. 

* **동작 원리**: 수신자는 TCP 세그먼트를 받으면 일단 '수신 버퍼(RcvBuffer)'에 쌓아둡니다. 
* 수신자는 **자신의 버퍼에 남은 여유 공간(`free buffer space`)**을 TCP 헤더의 **`rwnd` (Receive Window)** 필드에 적어서 송신자에게 **ACK**와 함께 보냅니다. 
* 송신자는 이 `rwnd` 값을 보고, "아, 수신자가 4000바이트만 더 받을 수 있구나"를 파악하고, 그 크기를 초과하지 않게 전송량을 조절합니다. 
* **Zero Window**: 수신자 버퍼가 꽉 차면 `rwnd = 0`을 보냅니다. 송신자는 전송을 일시 중단합니다. 
* **SWS (멍청한 윈도우 증후군)**: `rwnd`가 찔끔 열릴 때마다 작은 패킷을 보내 효율이 떨어지는 문제. Nagle 알고리즘(송신측, 데이터 모아보내기) / Clark's Solution(수신측, 버퍼가 충분히 확보될 때까지 ACK 지연) 으로 해결.

---

## 6. 🚦 TCP 혼잡 제어 (Congestion Control)


**"네트워크 전체"**의 혼잡(마비)을 방지하는 기능입니다. 

### 흐름 제어 vs 혼잡 제어 (필수 암기)



| 구분 | 흐름 제어 (Flow Control) | 혼잡 제어 (Congestion Control) |
| :--- | :--- | :--- |
| **문제 위치** | 1:1 (송신자 ↔ **수신자**) | N:N (송신자 ↔ **네트워크 전체**) |
| **목적** | **수신자 버퍼** 오버플로 방지 | **네트워크 혼잡** (라우터 손실) 방지 |
| **기준 변수** | **`rwnd`** (수신자가 알려줌) | **`cwnd`** (송신자가 스스로 계산) |
| **제어 주체** | 수신자 (Receiver-driven) | 송신자 (Sender-driven) |



> **TCP의 실제 전송 가능량 = `min(rwnd, cwnd)`**
> (흐름 제어가 "보내도 돼"라고 해도(rwnd 큼), 혼잡 제어가 "보내지 마!"라고 하면(cwnd 작음) 보낼 수 없습니다.) 

### 혼잡이 발생하면?

* 라우터 큐가 가득 차면서 **지연(Delay)이 급증**합니다. 
* 큐가 넘쳐서 **패킷 손실(Loss)이 발생**합니다. 
* 손실된 패킷을 **재전송**하느라 불필요한 부하가 증가합니다. 
* 악순환이 반복되면 실제 **처리율(Throughput)이 감소**합니다. 

### 혼잡 제어 원리: AIMD

TCP는 네트워크 상태를 "떠보면서(probing)" 속도를 조절합니다. 

* **AIMD**: Additive Increase / Multiplicative Decrease (합 증가 / 곱 감소) 
* **원리**: "조심스럽게 속도를 올리다가(1, 2, 3...) , 문제가 생기면(손실) 속도를 절반으로 확 줄인다(50%)" .
* **합 증가 (AI)**: 혼잡이 없을 때, 1 RTT마다 `cwnd`를 1씩(선형) 증가. 
* **곱 감소 (MD)**: 혼잡(손실) 발생 시, `cwnd`를 1/2로(지수적) 감소. 
* **결과**: 톱니바퀴(sawtooth) 모양의 전송 속도 그래프가 그려집니다. 

 

### TCP 혼잡 제어 4단계 알고리즘 

AIMD는 `cwnd`가 이미 높을 때의 동작이고, 처음 연결 시에는 더 빠른 방법이 필요합니다.

1.  **Slow Start (느린 시작)**
    * **목적**: 네트워크 대역폭을 빠르게 탐색.
    * **동작**: `cwnd`를 1 MSS에서 시작, 1 RTT마다 `cwnd`를 **2배씩 증가** (지수적 증가) .
    * **종료**: `cwnd`가 `ssthresh`(경계값)에 도달하거나 패킷 손실이 발생하면 종료.

2.  **Congestion Avoidance (혼잡 회피)**
    * **목적**: `ssthresh`에 도달한 이후, 네트워크를 포화시키지 않기 위해 조심스럽게 증가.
    * **동작**: 1 RTT마다 `cwnd`를 **1 MSS씩 증가** (선형 증가, AIMD의 'AI' 부분) .

3.  **Congestion Detection (혼잡 감지)**
    * **신호 1 (심각): Timeout 발생** 
        * 의미: 패킷과 ACK가 모두 사라질 정도의 심각한 혼잡.
    * **신호 2 (경미): 3-Duplicated ACK (3중 중복 ACK)** 
        * 의미: 패킷 하나(예: 2번)만 손실되고, 3, 4, 5번은 잘 도착함 (수신자가 "2번 줘, 2번 줘, 2번 줘"라고 동일 ACK 3번 보냄).
        * "빠른 재전송(Fast Retransmit)"이 발동됨. 

4.  **Congestion Recovery (혼잡 회복)**
    * **Timeout 발생 시 (가장 강력한 처벌)** :
        * `ssthresh = cwnd / 2` (현재 속도의 절반을 경계로 설정) 
        * **`cwnd = 1`** (완전히 처음으로 리셋) 
        * **`Slow Start`** 단계부터 다시 시작. 
    * **3-Duplicated ACK 발생 시 (빠른 회복)** :
        * `ssthresh = cwnd / 2` 
        * **`cwnd = ssthresh`** (절반으로만 줄이고 1로 리셋하지 않음) 
        * **`Congestion Avoidance`** 단계(선형 증가)부터 즉시 다시 시작. 

---

## 7. 🔬 TCP 소켓 프로그래밍 실습 (Python)


이론으로 배운 TCP가 실제로 어떻게 동작하는지 Python과 Wireshark로 확인합니다.

### 실습 1: 기본 TCP 에코(Echo) 통신


클라이언트가 보낸 메시지를 서버가 그대로 돌려주는 예제입니다.

* `echo_server.py` (서버 코드) 
    * `socket(AF_INET, SOCK_STREAM)`: **TCP 소켓** 생성 
    * `s.bind((HOST, PORT))`: '0.0.0.0'의 5000번 포트에 바인딩 
    * `s.listen()`: "영업 시작" (연결 대기 시작) 
    * `conn, addr = s.accept()`: **(중요)** 클라이언트 연결 요청이 올 때까지 **대기(Block)**. 연결 수립 시, 클라이언트와 통신할 **새로운 소켓(`conn`)**을 반환 
    * `conn.recv(1024)` / `conn.sendall(data)`: 연결된 클라이언트(`conn`)와 데이터 송수신 

* `echo_client.py` (클라이언트 코드) 
    * `socket(AF_INET, SOCK_STREAM)`: **TCP 소켓** 생성 
    * `c.connect((HOST, PORT))`: 서버 '127.0.0.1'의 5000번 포트에 **연결 요청 (3-way handshake 시작)** 
    * `c.sendall(msg.encode())` / `c.recv(1024)`: 서버와 데이터 송수신 

* **실행 결과**: 서버는 5000번 포트에서 대기하고 , 클라이언트가 접속하면(`Connected by... 55347`) , 메시지를 주고받습니다 .

### 실습 2: 멀티 클라이언트 서버 (Thread 기반)


기본 에코 서버는 한 번에 한 명의 클라이언트만 받을 수 있습니다. TCP의 **연결별 독립성**을 활용하여 여러 클라이언트를 동시에 처리하는 서버입니다. 

* `threads_server.py` (멀티스레드 서버) 
    * `s.accept()`로 클라이언트(예: 55202번)가 접속하면 ,
    * `handle_client` 함수를 **새로운 스레드(Thread)로 생성**하여 그 클라이언트 전담 마크맨으로 붙여줍니다. 
    * 메인 스레드는 다시 `s.accept()`로 돌아가 다음 클라이언트(예: 55203번)를 기다립니다. 
* **실행 결과**: 서버가 55202번 클라이언트 와 55203번 클라이언트 의 메시지를 **동시에** 독립적으로 처리하는 것을 볼 수 있습니다.

### 실습 3: Wireshark 관찰


실제 TCP 패킷을 캡처하여 이론과 일치하는지 확인합니다. (필터: `tcp port 5000` 또는 `tcp.stream eq 0`) 

1.  **연결 수립 (3-Way Handshake)** 
    * 패킷 1: `[SYN]` (클라이언트 `55417` → 서버 `5000`) 
    * 패킷 2: `[SYN, ACK]` (서버 `5000` → 클라이언트 `55417`) 
    * 패킷 3: `[ACK]` (클라이언트 `55417` → 서버 `5000`) 

2.  **데이터 전송 (Echo)** 
    * 패킷 4: `[PSH, ACK]` 클라이언트가 8바이트 데이터 전송 (`Seq=1`) 
    * 패킷 5: `[ACK]` 서버가 8바이트 수신 확인 (`Ack=9` (1+8)) 
    * 패킷 6: `[PSH, ACK]` 서버가 8바이트 데이터 에코 (`Seq=1`) 
    * 패킷 7: `[ACK]` 클라이언트가 8바이트 수신 확인 (`Ack=9` (1+8)) 

3.  **두 번째 클라이언트 연결 (Stream 1)**
    * 패킷 12: `[SYN]` (클라이언트 `55418` → 서버 `5000`) 
    * (패킷 13, 14 ... Stream 1의 3-way handshake 진행) 
    * **결과**: Wireshark가 `tcp.stream` 인덱스를 0과 1로 구분. TCP가 4-tuple로 연결을 완벽히 분리함을 증명합니다.

4.  **연결 종료 (4-Way Handshake) - (Stream 0)** 
    * 패킷 17: `[FIN, ACK]` (클라이언트 `55417` → 서버 `5000`) 
    * 패킷 18: `[ACK]` (서버 `5000` → 클라이언트 `55417`) 
    * 패킷 19: `[FIN, ACK]` (서버 `5000` → 클라이언트 `55417`) 
    * 패킷 20: `[ACK]` (클라이언트 `55417` → 서버 `5000`) 

5.  **기타 분석**
    * **재전송**: `tcp.analysis.retransmission` 필터 (실습에서는 손실이 없어 결과 없음) 
    * **윈도우 업데이트**: `tcp.analysis.window_update` . `Window size scaling factor: 256` 옵션이 사용되어 , 16비트(65535) 헤더 값 이 실제로는 `2619648`바이트로 동작함을 확인. 
    * **연결 강제 종료 (RST)**: 실습 중 클라이언트(`55425`)를 강제 종료(`Ctrl+C`)하자, `[RST, ACK]` 패킷이 전송되어 연결이 즉시 끊김 (4-way handshake 무시). 

---

(페이지 56)
감사합니다.
