안녕하세요. 6주차 강의 자료인 'Socket(TCP/UDP)'에 대해 요청하셨네요.

이 자료는 사용자님처럼 컴퓨터 공학을 전공하고[USER_CONTEXT] 웹 개발 및 배포에 관심이 많은[USER_CONTEXT] 분에게 **가장 중요한 핵심 원리** 중 하나입니다. 우리가 만드는 모든 네트워크 애플리케이션(웹 서버, 클라이언트, API 등)이 실제로 통신하는 '창구'가 바로 소켓(Socket)이기 때문입니다.

PDF의 모든 내용을 처음부터 끝까지, 빠짐없이 쉽게 풀어서 설명해 드리겠습니다.

---

# 🖥️ 컴퓨터네트워크: 6주차 소켓 (TCP/UDP)



이 자료는 6주차 강의 내용으로, 이전의 애플리케이션 계층(WWW, HTTP) 에 이어, 그 애플리케이션이 어떻게 전송 계층(TCP/UDP)과 통신하는지에 대해 다룹니다.

## 1. 🤝 응용 계층과 전송 계층의 관계

* **응용 계층**: 우리가 실제로 사용하는 프로그램 (웹 브라우저, 메신저 등)이 있는 층입니다. 
* **전송 계층 (TCP/UDP)**: 이 응용 프로그램들끼리 데이터를 안정적으로(TCP) 또는 빠르게(UDP) 주고받도록 도와주는 **"배달 서비스"** 역할을 합니다. 

이 두 계층은 **소켓(Socket)**이라는 연결 통로를 통해 데이터를 주고받습니다. 

> **[응용계층]** 브라우저 (프로세스)
>
> ↕ (소켓 연결) 
>
> **[전송계층]** TCP (내 PC의 임의 포트 50000 사용) 
>
> ... 네트워크 ...
>
> **[전송계층]** TCP (서버의 80번 포트) 
>
> ↕
>
> **[응용계층]** 웹 서버 (프로세스) 

---

## 2. 🔑 핵심 개념: 프로세스, 포트, 소켓



이 세 가지 개념을 이해하는 것이 중요합니다.

* **프로세스 (Process)**: 현재 "실행 중인 프로그램"입니다. (예: 크롬 브라우저, 카카오톡 프로그램) 
* **포트 번호 (Port Number)**: 전송 계층이 수많은 프로세스 중 **어떤 프로세스에게** 데이터를 전달할지 구분하기 위한 **"번호표"**입니다. (예: 웹 서버는 80번, HTTPS 서버는 443번 포트를 사용) 
* **소켓 (Socket)**: 이 프로세스와 포트 번호를 연결하는 실제 **"연결 통로"**입니다. 소켓은 **IP 주소 + 포트 번호**의 조합으로 식별됩니다. (예: `192.168.1.10:5000`) 

### 🏢 건물 비유



| 비유 | 실제 개념 | 설명 |
| :--- | :--- | :--- |
| **건물** | **컴퓨터 (IP 주소)** | 하나의 컴퓨터(건물) 안에는 여러 프로그램(방)이 있습니다. |
| **방 번호** | **포트 번호 (Port)** | 건물 안의 각 방(프로세스)을 구분하는 번호입니다. |
| **사람** | **응용 프로그램 (Process)** | 실제로 데이터를 주고받는 주체(사람)입니다. |
| **문** | **소켓 (Socket)** | 데이터가 실제로 드나드는 통로입니다. **(IP 주소 + 포트 번호가 결합된 '문')** |

---

## 3. 🔌 소켓 API (Socket Interface)



소켓은 응용 계층과 전송 계층 사이의 **인터페이스(연결 통로)**입니다. 

* **소켓 (Socket)**: 응용 프로그램이 커널(OS)의 TCP/UDP 기능에 요청을 보내기 위한 **"문의 손잡이(handle)"**입니다. 
* **주소 (Address)**: `IP + Port`의 조합입니다. 
* **연결 (Connection)**: TCP는 연결 지향 (3-way-handshake) , UDP는 비연결형 (데이터그램)입니다. 
* **엔드포인트 (End Point)**: (로컬 IP:Port, 원격 IP:Port)의 완전한 연결 쌍을 의미합니다. 

### 소켓 생성 시 옵션

소켓을 생성할 때는 3가지 옵션을 지정합니다. (C언어 기준) 

1.  **도메인 (Domain)**: 어떤 주소 체계를 쓸 것인가? 
    * `AF_INET`: IPv4 (우리가 흔히 쓰는 IP 주소) 
    * `AF_INET6`: IPv6 
2.  **타입 (Type)**: 어떤 전송 방식을 쓸 것인가? 
    * `SOCK_STREAM`: TCP (스트림 방식, 신뢰성 O) 
    * `SOCK_DGRAM`: UDP (데이터그램 방식, 신뢰성 X) 
3.  **프로토콜 (Protocol)**: 보통 0을 쓰면 타입에 따라 자동 결정됩니다. (예: `IPPROTO_TCP`, `IPPROTO_UDP`) 

### 소켓 공통 API (C 기반 함수)



* `socket(domain, type, protocol)`: 소켓을 생성하고 "손잡이"(파일 디스크립터, fd)를 반환받습니다. 
* `bind(fd, 주소)`: **서버**에서 필수적인 함수. 소켓(fd)을 특정 로컬 IP와 포트 번호에 고정(바인딩)시킵니다. (예: 80번 포트에 고정) 
    * 클라이언트는 보통 이 과정을 생략하며, OS가 알아서 남는 포트(임시 포트)를 자동 배정합니다. 
* `connect(fd, 원격지주소)`: **클라이언트**가 원격지(서버)와 논리적 연결을 맺습니다.
    * TCP의 경우: 3-way-handshake가 시작됩니다. 
    * UDP의 경우: "목적지 기본값 설정" 정도의 의미입니다. 
* `send(data)` / `recv(buffer)`: **TCP**처럼 "연결 지향" 방식에서 데이터를 송수신합니다. 
* `sendto(data, 목적지주소)` / `recvfrom(buffer)`: **UDP**처럼 "비연결" 방식에서 목적지 주소를 매번 지정하며 데이터를 송수신합니다. 
* `close(fd)`: 소켓 자원을 해제합니다. 

---

## 4. 🔄 TCP vs UDP 표준 흐름 비교



두 프로토콜은 소켓을 사용하는 절차가 다릅니다.

### TCP (연결 지향)



| TCP 서버 (손님을 기다림) | TCP 클라이언트 (손님이 찾아감) |
| :--- | :--- |
| 1. `socket()` - 가게 문 만들기 | 1. `socket()` - 문 만들기 |
| 2. (`setsockopt()`) - 옵션 설정 | 2. (`bind()`) - (선택 사항) |
| 3. `bind()` - **가게 간판 걸기 (예: 80번 포트)** | |
| 4. `listen()` - **"영업 시작" (손님 받을 준비)** | |
| | 3. `connect()` - **가게에 전화 걸기 (연결 시도)** |
| 5. `accept()` - **손님 1명 받기 (연결 수락)** | |
| 6. `recv() / send()` - 손님과 대화 | 4. `send() / recv()` - 주문 및 응답 받기 |
| 7. `close()` - 손님 응대 종료 | 5. `close()` - 전화 끊기 |



### UDP (비연결형)



| UDP 서버 (우편함) | UDP 클라이언트 (편지 발송자) |
| :--- | :--- |
| 1. `socket(SOCK_DGRAM)` - 우편함 만들기 | 1. `socket(SOCK_DGRAM)` - 편지지 준비 |
| 2. `bind()` - **우편함 주소(포트) 정하기** | 2. (`bind()`) - (선택: 내 주소 지정) |
| 3. `recvfrom()` - **우편함에서 편지 확인** | 3. `sendto(data, 서버주소)` - **편지 발송** |
| 4. `sendto(data, 발신자주소)` - (필요시) 답장 보내기 | 4. `recvfrom()` - (필요시) 답장 확인 |
| 5. `close()` - 우편함 닫기 | 5. `close()` - 편지쓰기 종료 |



### 📊 TCP vs UDP 요약

| 항목 | TCP | UDP |
| :--- | :--- | :--- |
| **연결** | **연결형** (3-way handshake) | **비연결형** |
| **함수** | `listen()`, `accept()`, `send/recv` | `sendto()`, `recvfrom()` |
| **신뢰성** | **O** (재전송, 순서보장) | **X** (손실, 순서 뒤바뀜 가능) |
| **용도** | 파일전송, 웹(HTTP), 메일 (신뢰성 중요) | DNS, DHCP, 스트리밍, 게임 (속도 중요) |
| **데이터 단위** | 스트림 (Stream, 경계 없음) | 데이터그램 (Datagram, 패킷 경계 있음) |



---

## 5. 📨 2부: UDP 상세



* **이름**: User Datagram Protocol 
* **형태**: 비연결형 (Connectionless) 
* **신뢰성**: **보장 안 함** (손실, 중복, 순서 바뀜 모두 가능) 
* **흐름/혼잡 제어**: **없음** (그냥 보냄) 
* **속도**: 빠름 (헤더가 단순하고 제어 로직이 없음) 
* **사용 시점**: 실시간성(게임, VoIP)이 중요하거나, 단문 전송(DNS, DHCP)에 사용 

### UDP 헤더 구조 (8바이트 고정)


UDP는 IP 헤더 뒤에 붙으며, 헤더가 **단 8바이트**로 매우 단순합니다. 


| 0~15 비트 | 16~31 비트 |
| :--- | :--- |
| **발신 포트 번호 (Source Port)** | **수신 포트 번호 (Destination Port)** |
| (패킷 전체) **길이 (Length)** | (오류 검증용) **체크섬 (Checksum)** |
| ... 데이터 ... | |



### 캡슐화와 다중화

* **캡슐화 (Encapsulation)**:
    1.  응용 프로그램이 `Message`를 만듭니다. 
    2.  UDP가 `UDP 헤더`를 붙입니다. 
    3.  IP가 `IP 헤더`를 붙입니다. 
    4.  데이터링크가 `Frame 헤더`를 붙여 전송합니다. 
    * 수신측(Receiver)은 이 과정을 거꾸로(역캡슐화) 수행합니다. 
* **다중화 (Multiplexing)**: 발신 측에서, 여러 프로세스(P1, P2, P3)의 데이터를 모아 UDP가 처리한 뒤 IP로 내려보냅니다. 
* **역다중화 (Demultiplexing)**: 수신 측에서, IP로부터 받은 UDP 패킷을 **헤더의 '수신 포트 번호'**를 보고 정확한 프로세스(P1, P2, P3)의 '방'으로 배달합니다. 

---

## 6. 🔬 3부: UDP Echo 실습 (Python)



클라이언트가 메시지를 보내면 서버가 받은 그대로 돌려주는(Echo) 예제입니다.

* `udp_server.py`: 클라이언트의 메시지를 받아 그대로 돌려줍니다. 
* `udp_client.py`: 사용자 입력을 서버로 전송하고, 에코를 수신합니다. 

### UDP Echo 통신 흐름도




| UDP 서버 | UDP 클라이언트 |
| :--- | :--- |
| `socket()` (소켓 생성) | `socket()` (소켓 생성) |
| `bind()` (포트 고정) | |
| `recvfrom()` (메시지 대기) | ← `sendto()` (메시지 전송) |
| `sendto()` (에코 발송) | → `recvfrom()` (에코 수신) |
| `close()` | `close()` |

* **서버 프로세스**: `socket` → `bind` → `(Receive → Send)` 반복 → `close` 
* **클라이언트 프로세스**: `socket` → `(Send → Receive)` 반복 → `close` 

UDP 서버는 **연결** 개념이 없기 때문에, `listen()`이나 `accept()`가 필요 없습니다. 그냥 `bind()`로 포트를 열어두고, `recvfrom()`으로 오는 모든 클라이언트의 메시지를 순서대로 처리합니다. 

### Python 코드 분석

#### 1. `udp_server.py` 

```python
# 필요한 모듈 임포트
import socket, sys, signal 

# 기본 호스트 '0.0.0.0' (모든 IP에서 받음), 포트 5000
DEFAULT_HOST = "0.0.0.0" 
DEFAULT_PORT = 5000 
BUF_SIZE = 4096 

def main():
    host = DEFAULT_HOST
    port = DEFAULT_PORT
    # ... (명령줄 인자로 포트 변경하는 로직) ... 

    # 1. 소켓 생성 (IPv4, UDP 방식)
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s: 
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # (옵션)
        
        # 2. 소켓을 주소와 포트에 바인딩 (간판 걸기)
        s.bind((host, port)) 
        print(f"[ ] UDP Echo Server listening on {host}:{port}") 
        
        # ... (Ctrl+C 처리 로직) ... 

        # 3. 무한 루프: 메시지 대기
        while True: 
            # 4. 메시지 수신 (데이터와 클라이언트 주소 반환)
            data, client = s.recvfrom(BUF_SIZE) 
            
            # 5. 받은 데이터를 '그 클라이언트에게' 그대로 돌려보냄
            s.sendto(data, client) 
            print(f"[recv] {client[0]}:{client[1]} ...") 

if __name__ == "__main__":
    main()
```


#### 2\. `udp_client.py`

```python
import socket, sys 
BUF_SIZE = 4096 

def main():
    # 1. 서버 IP, Port를 명령줄 인자로 받음
    if len(sys.argv) < 3: 
        print("Usage: python udp_client.py <server_ip> <server_port>") 
    server_ip = sys.argv[1] 
    server_port = int(sys.argv[2]) 

    # 2. 소켓 생성 (IPv4, UDP)
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s: 
        # 3. (중요) 클라이언트 포트를 '0'으로 바인딩
        # -> OS에게 "알아서 남는 포트 하나 배정해줘" (임시 포트)
        s.bind(("0.0.0.0", 0)) 
        
        print(f"[i] Client local endpoint before send: {s.getsockname()}") 
        
        while True:
            # 4. 사용자 입력 받기
            msg = input("> ") 
            if not msg: break 

            # 5. 메시지를 '서버 주소'로 전송
            s.sendto(msg.encode("utf-8"), (server_ip, server_port)) 
            
            s.settimeout(2.0) # 2초 타임아웃 설정 
            try:
                # 6. 서버로부터 (에코) 데이터 수신
                data, srv = s.recvfrom(BUF_SIZE) 
                print(f"[recv] {srv[0]}:{srv[1]} -> ...") 
            except socket.timeout: 
                print("[!] No echo received (timeout).") 

if __name__ == "__main__":
    main() 
```

### 실습 실행 결과 분석

1.  **서버 실행**

      * `py -3 udp_server.py` 실행
      * 서버가 `0.0.0.0:5000`에서 리스닝(대기) 시작

2.  **클라이언트 1 실행**

      * `py -3 udp_client.py 127.0.0.1 5000` 실행
      * OS가 클라이언트 1에게 임시 포트 `49740` 할당
      * `> client1` 입력 및 전송
      * **서버 로그**: `[recv] 127.0.0.1:49740 ... b'client1'` (49740 포트에서 받음)
      * **클라이언트 로그**: `[recv] 127.0.0.1:5000 ... client1` (서버 5000으로부터 에코 받음)

3.  **클라이언트 2 실행 (동시에)**

      * (다른 터미널에서) `py -3 udp_client.py 127.0.0.1 5000` 실행
      * OS가 클라이언트 2에게 **다른** 임시 포트 `50061` 할당
      * `> client2` 입력 및 전송
      * **서버 로그**: `[recv] 127.0.0.1:50061 ... b'client2'` (50061 포트에서 받음)
      * **클라이언트 로그**: `[recv] 127.0.0.1:5000 ... client2` (서버 5000으로부터 에코 받음)

**결론**: 서버는 단일 소켓(5000번)으로, 여러 클라이언트(49740번, 50061번)의 요청을 `recvfrom`으로 구분하여 받고, `sendto`로 정확한 상대에게 답장(에코)을 보냈습니다.

### Wireshark 캡처 분석

(로컬 통신(127.0.0.1)이므로 루프백 인터페이스를 캡처)

  * **패킷 2**: `127.0.0.1` (Src Port: `52162`) → `127.0.0.1` (Dst Port: `5000`) (클라이언트 1 → 서버)
  * **패킷 3**: `127.0.0.1` (Src Port: `5000`) → `127.0.0.1` (Dst Port: `52162`) (서버 → 클라이언트 1 에코)
  * **패킷 8**: `127.0.0.1` (Src Port: `50442`) → `127.0.0.1` (Dst Port: `5000`) (클라이언트 2 → 서버)
  * **패킷 9**: `127.0.0.1` (Src Port: `5000`) → `127.0.0.1` (Dst Port: `50442`) (서버 → 클라이언트 2 에코)

Wireshark 캡처 결과는 터미널 로그와 정확히 일치하며 , UDP 통신에서 포트 번호가 어떻게 사용되는지 명확히 보여줍니다.

### 📝 과제

1.  각자 UDP Echo 테스트를 실행합니다.
2.  전송 내용에 '학과, 학번, 이름'을 포함시킵니다.
3.  Wireshark 캡처 파일(학번.pcapng) 과 터미널 캡처 화면(학번.png) 을 과제방에 업로드합니다.

-----

(페이지 42)
감사합니다.

```
```
