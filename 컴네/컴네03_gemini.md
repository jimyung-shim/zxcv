안녕하세요! 컴퓨터 네트워크 3주차 강의인 'WWW & HTTP' PDF 파일의 전체 내용을 빠짐없이, 술술 읽히도록 쉽게 풀어서 설명해 드리겠습니다.

컴퓨터 공학을 전공하고 계시고[USER_CONTEXT] 웹 개발에 관심이 많으시니[USER_CONTEXT], 이번 자료는 사용자님의 핵심 관심 분야와 직결되는 내용입니다. 웹이 어떻게 동작하는지, 브라우저(클라이언트)와 서버가 어떤 '언어'로 대화하는지 자세히 알아보겠습니다.

---

# 🖥️ 컴퓨터네트워크: 3주차 WWW & HTTP



이 자료는 3주차 강의 내용으로, 주제는 **WWW(World Wide Web)**와 **HTTP(Hypertext Transfer Protocol)**입니다. 이전에 배운 애플리케이션 계층과 프로토콜의 개념을 바탕으로 , 웹의 핵심 프로토콜인 HTTP를 자세히 다룹니다.

## 1. 📖 복습: 프로토콜이란?

본격적인 내용에 앞서, 이전 강의 내용을 복습합니다.

### 프로토콜의 개념

프로토콜은 "통신 규약" 또는 "약속"입니다. 

* **사람 간의 프로토콜**: 우리가 대화하는 방식과 같습니다. 
    * A: "Hi" (안녕) 
    * B: "Hi" (안녕) 
    * A: "Got the time?" (지금 몇 시야?) 
    * B: "2:00" (2시야) 
* **컴퓨터 네트워크 프로토콜**: 기계들도 정해진 규칙으로 메시지를 주고받습니다. 
    * 클라이언트: "TCP connection request" (TCP 연결 요청할게) 
    * 서버: "TCP connection response" (TCP 연결 응답할게) 
    * 클라이언트: "GET http://..." (이 주소의 파일 줘) 
    * 서버: `<file>` (여기 파일이야) 

### 네트워크 계층 모델 (OSI 7계층 vs TCP/IP 4계층)

네트워크 통신은 여러 단계(계층)로 나뉩니다. 

* **OSI 7계층 모델**: 개념적으로 통신을 7단계로 나눈 표준 모델입니다. (물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용) 
* **TCP/IP 프로토콜 그룹**: 현재 인터넷이 실제로 사용하는 모델입니다. OSI 모델을 더 실용적으로 묶었습니다. 
    * OSI의 응용, 표현, 세션 계층을 → **Application(응용) 계층**으로 묶음 
    * OSI의 전송 계층 → **Tansport(전송) 계층** (TCP, UDP) 
    * OSI의 네트워크 계층 → **Network(네트워크) 계층** (IP) 
    * OSI의 물리, 데이터링크 계층 → **Data link/Physical 계층** (LAN, WAN) 

데이터는 각 계층을 내려갈 때마다 '헤더'라는 정보가 덧붙여(캡슐화)집니다. 

* 응용층: **Message** (응용 특수 주소) 
* 전송층: **Segment** (포트 주소) 
* 네트워크층: **Datagram** (논리 주소 - IP) 
* 데이터 링크층: **Frame** (물리 주소 - MAC) 
* 물리층: **Bits** 

### 주소(식별자) 구분

각 계층은 서로 다른 주소 체계를 사용합니다. 

| 계층 | 이름 | 길이/형식 | 범위 | 사용 주체 | 역할 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **L2** | **MAC 주소** | 48bit | 같은 LAN | 스위치 | LAN 내부에서 다음 장치 식별 |
| **L3** | **IP 주소** | 32bit(IPv4) / 128bit(IPv6) | 네트워크 전체 (인터넷) | 라우터 | 서로 다른 네트워크 간 최종 목적지 호스트 식별 |
| **L4** | **포트 번호** | 16bit (0~65535) | 호스트 내부 | OS 커널 (TCP/UDP) | 한 컴퓨터 안의 여러 서비스(프로세스) 구분 |
| **L4+** | **소켓** | 5-튜플 (프로토콜, 출발지IP/Port, 목적지IP/Port) | 연결/플로우 단위 | 커널 & 앱 | 실제 통신 연결 그 자체 |



### 애플리케이션 계층에서 배울 것들

우리는 이 중 최상위 계층인 **애플리케이션 계층**에 집중합니다. 

* **패러다임**: 클라이언트-서버 모델 , P2P 모델 
* **주요 프로토콜**: **HTTP** , SMTP/IMAP (이메일) , DNS , 비디오 스트리밍/CDN 
* **프로그래밍**: **소켓 API** 

### 프로토콜을 정의하는 요소

프로토콜은 4가지 요소로 정의됩니다. 

1.  **형식 (Syntax)**: 메시지의 구조와 문법. (예: `GET /path HTTP/1.1`이라는 텍스트 형식) 
2.  **의미 (Semantics)**: 각 필드의 값이 무엇을 의미하는지. (예: HTTP 200 코드는 '성공'을 의미) 
3.  **순서/타이밍 (Order & Timing)**: 메시지를 주고받는 순서와 시간 제약. (예: TCP 3-way handshake 순서) 
4.  **상태 (State)**: 연결 상태를 기억하고 상태가 어떻게 변하는지. (예: TCP의 ESTABLISHED 상태) 

프로토콜은 **개방형(Open)**과 **독점(Proprietary)**으로 나뉩니다. 

* **개방형 프로토콜**: RFC 문서로 표준이 공개되어 누구나 구현할 수 있습니다. 상호운용성이 보장됩니다. (예: HTTP, SMTP) 
* **독점 프로토콜**: 특정 회사가 관리하며 사양이 비공개일 수 있습니다. (예: Zoom) 

### 전송 계층 서비스: TCP vs UDP

애플리케이션 계층은 그 바로 아래 전송 계층의 서비스(TCP 또는 UDP)를 이용합니다. 

* **TCP (신뢰성 있는 전송)** 
    * **신뢰성** 보장, 흐름 제어, 혼잡 제어 
    * **연결 지향** (3-way handshake 필요) 
    * 타이밍, 최소 속도, 보안은 보장 **안 함** 
    * **주요 사용처**: HTTP, FTP, SMTP (데이터 손실이 없어야 하는 서비스) 
* **UDP (신뢰성 없는 전송)** 
    * 신뢰성, 흐름 제어, 혼잡 제어, 타이밍, 속도 보장 **모두 안 함** 
    * 그냥 데이터를 '최선을 다해' 전송 (Best-effort) 
    * **주요 사용처**: 스트리밍, 인터넷 전화, 온라인 게임 (약간의 손실이 있어도 속도가 더 중요한 서비스) 

### 보안: TLS (Transport Layer Security)

기본 TCP와 UDP는 암호화가 없어, 비밀번호 등이 평문으로 전송됩니다. 
이를 보완하기 위해 **TLS**가 등장했습니다. TLS는 TCP 연결 위에 암호화 계층을 추가하여 , **암호화**, **데이터 무결성** , **엔드포인트 인증** 을 제공합니다. (이것이 HTTPS의 핵심입니다.)

---

## 2. 🌐 WWW (World Wide Web) 와 HTTP

이제 본격적으로 3주차 주제인 WWW와 HTTP에 대해 알아봅니다. 

### WWW (World Wide Web) 란?

* WWW는 인터넷과 동의어가 아닙니다. WWW는 인터넷이라는 거대한 네트워크 위에서 동작하는 **하나의 서비스**입니다.
* "세계에 퍼져 있으면서 서로 연결되어 있는 지식의 보고"를 의미합니다. 
* 1989년 CERN(유럽입자물리연구소)에서 분산된 자원(문서)을 처리하기 위해 시작되었습니다. 
* WWW는 분산된 **클라이언트/서버 서비스**입니다. 
    * **클라이언트**: 브라우저(Chrome 등)를 사용 
    * **서버**: 웹 서버(Apache 등)
* 정보(웹 페이지)는 전 세계 여러 '사이트(site)'에 분산되어 저장됩니다. 
* 각 '웹 페이지(web page)'는 다른 페이지로 연결되는 '링크(link)'를 포함합니다. 

### 하이퍼텍스트와 하이퍼미디어

* **하이퍼텍스트 (Hypertext)**: 다른 문서를 참조(링크)하여 연결된 문서를 의미합니다. 
* **하이퍼미디어 (Hypermedia)**: 텍스트뿐만 아니라 사진, 비디오, 소리 등 다양한 미디어를 포함하여 링크하는 것을 의미합니다. 

### 웹 클라이언트와 웹 서버

* **웹 클라이언트 (브라우저)**: 웹 문서를 해석하여 사용자에게 보여주는 프로그램입니다. (예: 크롬, 파이어폭스) 브라우저 내부에는 HTML, JavaScript 등을 해석하는 인터프리터와 HTTP 같은 프로토콜이 내장되어 있습니다. 
* **웹 서버**: 웹 페이지를 저장하고 , 클라이언트의 요청이 오면 해당 문서를 전송해주는 소프트웨어입니다. 효율을 위해 캐시를 사용하거나 , 다중 스레드/프로세스 방식으로 동작합니다. (예: Apache, Microsoft IIS) 

### 웹 페이지 검색 (요청/응답)

웹 페이지를 가져오는 과정은 HTTP **Request(요청)**와 **Response(응답)**로 이루어집니다. 

* **단일 문서**: 클라이언트가 1번 요청하고 서버가 1번 응답하여 웹 페이지를 받습니다. 
* **복합 문서**: 현대의 웹 페이지는 HTML 문서 하나와 여러 개의 이미지, 스크립트 파일 등으로 구성됩니다. 
    1.  **Request 1**: HTML 문서 (A) 요청 
    2.  **Response 1**: HTML 문서 (A) 응답 
    3.  (브라우저가 A를 해석하다가 이미지 B와 파일 C가 더 필요한 것을 발견) 
    4.  **Request 2**: 이미지 (B) 요청 
    5.  **Response 2**: 이미지 (B) 응답 
    6.  **Request 3**: 파일 (C) 요청 (다른 사이트일 수도 있음) 
    7.  **Response 3**: 파일 (C) 응답 

### URL (Uniform Resource Locator)

클라이언트는 서버의 웹 페이지에 접속하기 위해 주소가 필요하며, 이를 **URL**이라고 부릅니다. 


URL의 기본 구조는 `프로토콜://호스트:포트/경로` 입니다. 
예: `https://www.cbnu.ac.kr/intro/intro.jsp` 

* **프로토콜 (Protocol)** 
    * 의미: 문서를 어떻게 요청하고 응답받을지에 대한 통신 규칙 
    * 예: `HTTP` , `HTTPS` (보안 HTTP) , `FTP` (파일 전송) 
* **호스트 (Host)** 
    * 의미: 정보가 저장된 서버(컴퓨터)의 주소 
    * 예: 도메인 이름 (`www.cbnu.ac.kr`) 또는 IP 주소 (`155.230.xxx.xxx`) . (DNS를 통해 도메인 이름이 IP로 변환됩니다) 
* **포트 (Port)** 
    * 의미: 서버 내에서 실행 중인 특정 서비스(프로그램)를 구분하는 번호 
    * 예: `HTTP`는 기본 80번 , `HTTPS`는 기본 443번 , `FTP`는 21번 
    * 기본 포트는 URL에서 생략 가능합니다. (예: `http://example.com:8080`처럼 기본이 아닐 때만 명시) 
* **경로 (Path)** 
    * 의미: 서버 내부에서 원하는 파일이나 프로그램이 있는 위치 
    * 예: `/intro/intro.jsp` (intro 폴더 안의 intro.jsp 파일) 

---

## 3. 📄 정적 문서 vs 동적 문서

웹 서버가 제공하는 문서는 크게 두 가지로 나뉩니다.

### 정적 문서 (Static Document)

* 서버에 이미 완성된 파일로 저장되어 내용이 고정된 문서입니다. 
* 클라이언트는 그 파일의 복사본을 받아갈 뿐입니다. 
* 예: `HTML`, `CSS`, `JavaScript` 파일, 이미지(`.jpg`), 동영상(`.mp4`) 등 

### 동적 문서 (Dynamic Document)

* 요청 시점에 서버에서 프로그램이 실행되어 **즉석에서 생성되는** 문서입니다. 
* 서버가 스크립트(JSP, PHP 등)를 실행하고 , 그 **실행 결과(주로 HTML)**를 클라이언트에게 응답으로 반환합니다. 
* 간단한 예로, 현재 날짜와 시간을 보여주는 페이지가 있습니다. 
* 예: `PHP`, `JSP`, `ASP` 등으로 작성된 파일 

### CGI (Common Gateway Interface)

동적 문서를 만들기 위한 초기 기술입니다. 

* CGI는 웹 서버와 외부 프로그램(애플리케이션) 간의 **표준 인터페이스(연결 규칙)**입니다. 
* C, Perl, Python 등 다양한 언어로 스크립트를 작성할 수 있습니다. 
* **동작 방식** 
    1.  클라이언트가 CGI 프로그램 URL을 요청 (예: `/form.cgi`) 
    2.  웹 서버가 요청을 받아 CGI 프로그램을 실행시킵니다. 
    3.  CGI 프로그램이 실행되어 DB 조회, 계산 등을 수행합니다. 
    4.  CGI 프로그램이 결과(HTML)를 웹 서버에 반환합니다. 
    5.  웹 서버가 이 결과를 클라이언트에게 최종 응답합니다. 
* **장점**: 표준화되어 어떤 언어로든 작성이 가능했습니다. 
* **단점**: **요청이 올 때마다 새로운 프로세스를 실행**해야 해서 , 트래픽이 많을 때 성능이 매우 느리고 비효율적이었습니다. 
* **현재**: 이런 단점 때문에 지금은 PHP, JSP, ASP, Python **WSGI** 같은 전용 웹 애플리케이션 서버 기술로 대부분 대체되었습니다. 

### WSGI (Web Server Gateway Interface)

CGI의 단점을 개선한 Python 전용 표준 인터페이스입니다. (사용자님이 사용하는 NestJS는 Node.js 기반이므로 비슷한 원리지만 다른 기술을 사용합니다.)

* **핵심**: 웹 서버(Nginx, Apache) 와 Python 웹 애플리케이션(Django, Flask) 사이를 연결하는 통신 규약입니다. 
* **동작 구조** 
    1.  사용자 요청이 웹 서버(Nginx)로 들어옵니다. 
    2.  웹 서버는 요청을 **WSGI 서버(Gunicorn, uWSGI)**에게 전달합니다. 
    3.  WSGI 서버가 Python 앱(Django)을 실행하여 요청을 처리합니다. 
    4.  앱이 응답을 WSGI 서버에게, WSGI 서버는 웹 서버에게, 웹 서버는 사용자에게 반환합니다. 
* **CGI와의 차이점 (성능)** 
    * **CGI**: 요청마다 새 프로세스 생성 (느림) 
    * **WSGI**: 이미 실행 중인 프로세스/스레드 재사용 (빠름) 
    * **결론**: WSGI 같은 현대 기술 덕분에 고성능 트래픽 처리가 가능해졌습니다. 

---

## 4. 🚀 HTTP (Hypertext Transfer Protocol) 상세

HTTP는 웹 브라우저와 서버가 요청(Request)과 응답(Response)을 주고받는 규칙입니다. 

### HTTP 트랜잭션과 특징


* HTTP는 TCP를 사용하지만 , 프로토콜 자체는 **상태가 없는(Stateless)** 프로토콜입니다. (서버가 클라이언트의 이전 요청을 기억하지 못한다는 의미입니다.)
* 항상 클라이언트가 **요청 메시지(Request message)**를 보내며 트랜잭션을 시작하고 , 서버가 **응답 메시지(Response message)**를 보내 답합니다. 

### (1) HTTP 요청 메시지 (Request)

요청 메시지는 4부분으로 구성됩니다. 
`Request line` (요청 라인)
`Headers` (헤더)
`A blank line` (빈 줄)
`Body` (본문)

#### ① 요청 라인 (Request Line)

메시지의 첫 줄로, 3가지 정보로 구성됩니다. 
`Method` (메소드) `URL` (경로) `Version` (버전) 
(예: `GET /test/sample.html HTTP/1.1`) 

**주요 HTTP 메소드** 

| 메소드 | 설명 |
| :--- | :--- |
| **GET** | **정보를 가져온다** (웹 페이지 조회) |
| **POST** | **많은 데이터를 송신한다** (로그인, 글쓰기, 파일 업로드) |
| HEAD | 정보의 헤더만 가져온다 |
| **PUT** | **서버에 파일을 업로드(수정)**한다 (전체 교체) |
| **DELETE** | **서버의 정보를 삭제**한다 |
| OPTIONS | 서버가 지원하는 메소드 정보를 요청한다 |
| TRACE | 요청 메시지를 그대로 다시 받는다 (디버깅용) |
| CONNECT | 프록시 서버 등과 터널을 만든다 |



#### ② 헤더 라인 (Header Lines)

클라이언트가 서버에게 보내는 **부가 정보**입니다. 

**주요 요청 헤더** 

| 헤더 이름 | 설명 |
| :--- | :--- |
| **Host** | **요청하는 서버의 호스트명과 포트 번호.** (필수) |
| **User-Agent** | 요청하는 웹 브라우저(클라이언트)의 정보. |
| **Accept** | 클라이언트가 받을 수 있는 문서 형식 (예: `text/html`, `image/png`). |
| Accept-Language | 클라이언트가 선호하는 언어 (예: `ko-KR`). |
| Accept-Encoding | 클라이언트가 받을 수 있는 압축 방식 (예: `gzip`). |
| **Connection** | 연결 상태 지정 (예: `keep-alive` - 연결 유지). |
| **Cookie** | 클라이언트가 보관 중인 쿠키 정보를 서버에 전달. |
| Referer | 이 페이지로 오기 직전의 페이지 주소. |



#### ③ 빈 줄 (Blank Line)

헤더의 끝을 알리는 `\r\n` (CR+LF) 개행 문자입니다. 

#### ④ 본문 (Body)

`GET` 요청에는 보통 본문이 없지만, `POST`나 `PUT` 요청 시 서버로 보낼 실제 데이터(예: 로그인 정보, 작성한 게시글 내용)가 이 부분에 담깁니다. 

### (2) HTTP 응답 메시지 (Response)

응답 메시지도 4부분으로 구성됩니다. 
`Status line` (상태 라인)
`Headers` (헤더)
`A blank line` (빈 줄)
`Body` (본문)

#### ① 상태 라인 (Status Line)

응답의 첫 줄로, 요청 처리 결과를 나타냅니다. 
`Version` (버전) `Status code` (상태 코드) `Phrase` (상태 문구) 
(예: `HTTP/1.1 200 OK`) 

**주요 HTTP 상태 코드** 

* **2xx (성공)**
    * **200 OK**: 클라이언트의 요청이 정상 처리됨. 
    * `206 Partial Content`: 정보의 일부만 응답함 (스트리밍, 이어받기). 
* **3xx (재지정 - Redirection)**
    * **301 Moved Permanently**: 요청한 자원이 **영구적으로** 새 URI로 이동함. 
    * `304 Not Modified`: (조건부 요청 시) 요청한 문서가 변경되지 않았음 (캐시 사용). 
* **4xx (클라이언트 오류)**
    * **400 Bad Request**: 요청 자체가 잘못됨 (문법 오류 등). 
    * **401 Unauthorized**: 인증(로그인)이 필요함. 
    * **403 Forbidden**: (로그인은 했지만) 접근 권한이 없음.
    * **404 Not Found**: **요청한 URI(페이지)를 서버에서 찾을 수 없음.** 
    * `408 Request Timeout`: 요청 시간이 초과됨. 
* **5xx (서버 오류)**
    * **500 Internal Server Error**: **서버 내부에서 에러 발생** (백엔드 코드 오류 등). 
    * `503 Service Unavailable`: 서비스 이용 불가 (서버 과부하, 점검 중). 



#### ② 헤더 라인 (Header Lines)

서버가 클라이언트에게 보내는 **부가 정보**입니다. 

**주요 응답 헤더** 

| 헤더 이름 | 설명 |
| :--- | :--- |
| **Content-Type** | **응답 본문(Body)의 데이터 형식.** (예: `text/html`, `image/png`) |
| **Content-Length** | 응답 본문의 크기(바이트). |
| **Server** | 응답을 보낸 웹 서버의 정보 (예: `Apache`). |
| Date | 응답 메시지를 생성한 날짜와 시간. |
| Last-Modified | 이 웹 페이지가 마지막으로 수정된 날짜. |
| **Set-Cookie** | **서버가 클라이언트(브라우저)에 쿠키를 저장하라고 명령.** |
| **Location** | 3xx 재지정 응답 시, 새로 이동할 URI(주소). |
| **Cache-Control** | 브라우저가 이 응답을 얼마나 오래 캐시(저장)해도 되는지 지정. |
| Connection | 현재 접속 상태 (예: `Keep-Alive`). |



#### ③ 빈 줄 (Blank Line)

헤더의 끝을 알리는 `\r\n` 개행 문자입니다. 

#### ④ 본문 (Body)

클라이언트가 요청한 실제 데이터(HTML 문서, 이미지 파일 등)가 담기는 곳입니다. 

### HTTP 통신 예시

* **문서 읽어오기 (GET)** 
    * **Client Request** 
        `GET /usr/bin/image1 HTTP/1.1`
        `Accept: image/gif`
        `Accept: image/jpeg` 
    * **Server Response** 
        `HTTP/1.1 200 OK` 
        `Date: Mon, 07-Jan-05 ...` 
        `Content-length: 2048` 
        `(이미지 파일 본문)` 

* **데이터 전송하기 (POST)** 
    * **Client Request** 
        `POST /cgi-bin/doc.pl HTTP/1.1` 
        `Content-length: 50` 
        `(본문에 50바이트의 입력 정보)` 
    * **Server Response** 
        `HTTP/1.1 200 OK` 
        `Content-length: 2000` 
        `(CGI 실행 결과 문서 본문)` 

* **Telnet으로 HTTP 요청 (수동)** 
    * `telnet www.mhhe.com 80` (서버 80번 포트로 접속) 
    * `GET /engcs/compsci/forouzan HTTP/1.1` (직접 요청 라인 입력) 
    * `From: ...` (헤더 입력) 
    * (서버가 `HTTP/1.1 200 OK` 응답과 헤더 , HTML 본문을 전송)

### 조건부 요청 (Conditional Request)

클라이언트는 캐시(Cache) 효율을 높이기 위해 조건을 달아 요청할 수 있습니다. 

* **`If-Modified-Since` 헤더**: "내가 가진 버전은 이 날짜(Thu, Sept 04) 이후로 수정되었니?"라고 묻는 것입니다. 
* **서버 응답 (304 Not Modified)** 
    * 만약 서버 파일이 그 이후로 수정되지 않았다면, 
    * 서버는 `304 Not Modified`라는 응답 코드만 보냅니다. 
    * 본문(Body)은 비어있습니다. 
    * 클라이언트는 "아, 안 바뀌었구나"하고 자신이 가진 캐시 버전을 그냥 사용합니다. (데이터 트래픽 절약)

### HTTP 연결 방식: 영속성

HTTP는 버전에 따라 TCP 연결을 관리하는 방식이 다릅니다. 

* **비영속적 연결 (Non-Persistent / HTTP 1.0)** 
    * **각 요청/응답마다** 새로운 TCP 연결을 만들고 닫습니다. 
    * (페이지 49 그림 참조) HTML 파일(file1) 1개, 이미지 2개(Image1, Image2)를 받으려면 **총 3번의 TCP 연결**(Connection establishment + termination)이 필요합니다. 
    * **단계**: (1) TCP 연결 → (2) 요청 → (3) 응답 → (4) TCP 연결 닫기. (이걸 3번 반복)
    * **단점**: 매우 비효율적입니다.

* **영속적 연결 (Persistent / HTTP 1.1 기본값)** 
    * **한 번의 TCP 연결**로 여러 개의 요청/응답을 처리합니다. 
    * (페이지 50 그림 참조) (1) TCP 연결 → (2) file1 요청/응답 → (3) Image1 요청/응답 → (4) Image2 요청/응답 → (5) TCP 연결 닫기. 
    * 서버는 타임아웃이 되거나 클라이언트가 요청할 때까지 연결을 열어 둡니다. 
    * (HTTP 1.1의 `Connection: keep-alive` 헤더가 이 기능을 제어합니다) 

---

## 5. 🍪 쿠키 (Cookies)

앞서 HTTP는 **Stateless(상태 없음)** 프로토콜이라고 했습니다. 하지만 현대 웹은 로그인, 장바구니 등 상태 유지가 필수입니다. (예: 전자상점 , 회원제 사이트 , 포털 개인화 )

이 문제를 해결하기 위해 **쿠키** 메커니즘이 도입되었습니다. 

### 쿠키 생성 및 저장

1.  클라이언트가 서버에 최초 요청을 보냅니다. 
2.  서버는 클라이언트를 식별하기 위한 정보(예: ID 12343)를 생성하여 파일이나 문자열로 저장합니다. 
3.  서버는 클라이언트에게 보내는 **응답(Response)**의 **`Set-Cookie: 12343`** 헤더에 이 정보를 포함시킵니다. 
4.  클라이언트(브라우저)는 이 응답을 받고, 쿠키(12343)를 자신의 쿠키 디렉터리에 (서버 도메인 이름과 함께) 저장합니다. 

### 쿠키 사용 (상태 유지)

1.  이후 클라이언트가 **같은 서버**에 **요청(Request)**을 보낼 때마다,
2.  브라우저는 저장해 둔 쿠키를 **`Cookie: 12343`** 헤더에 자동으로 포함시켜 전송합니다. 
3.  서버는 요청 헤더의 쿠키 값을 보고 "아, 이 사용자는 ID 12343이구나"라고 식별하여, 그 사용자의 장바구니 정보나 로그인 상태를 이어갈 수 있습니다.

### 쇼핑몰 예시 (페이지 54) 

1.  **Client (Request 1)**: `GET BestToys.com` (첫 방문) 
2.  **Server (Response 1)**: `HTTP/1.1 200 OK` + **`Set-Cookie: 12343`** (서버는 DB에 'ID 12343' 고객 파일 생성) 
3.  **Client (Request 2)**: `GET image` + **`Cookie: 12343`** (브라우저가 쿠키를 함께 전송)
4.  **Server (Response 2)**: `HTTP/1.1 200 OK` (서버가 쿠키를 보고 ID 12343임을 인지하고 장바구니 정보 업데이트) 
5.  (이후 모든 요청/응답에 쿠키가 포함되어 결제까지 상태가 유지됨) 

쿠키는 전자 상거래 , 회원제 사이트 , 웹 포털 개인화 , 광고 타겟팅 등에 널리 사용됩니다.

---

## 6. 🗄️ 웹 캐싱 (Web Caching)

웹 캐싱은 자주 요청되는 응답의 복사본을 **프록시 서버(Proxy Server)**에 저장해두는 기술입니다. 

* **동작 방식** 
    1.  HTTP 클라이언트가 원본 서버가 아닌 **프록시 서버**로 요청을 보냅니다. 
    2.  프록시 서버는 자신의 캐시(저장소)를 검사합니다. 
    3.  (캐시에 있으면 바로 응답. 없으면,)
    4.  프록시 서버가 원본 서버로 대신 요청을 보냅니다. 
    5.  원본 서버의 응답이 프록시 서버로 오면, 프록시 서버는 이를 **캐시에 저장**하고 클라이언트에게 전달합니다.
    6.  (다음 클라이언트가 같은 요청을 하면 3번 단계에서 바로 캐시된 응답을 받습니다.)
* **프록시 서버 위치** 
    * 주로 클라이언트 사이트(회사 내부망, ISP 등)에 위치합니다. 
    * 클라이언트 PC 자체에도 작은 캐시가 있을 수 있습니다. 
    * 회사 LAN에 설치되어 외부로 나가는 트래픽을 줄일 수 있습니다. 
    * ISP(통신사)가 설치하여 ISP 네트워크 트래픽을 줄일 수 있습니다. 

(참고: 지난주에 배운 CDN이 바로 이 웹 캐싱을 전 세계 규모로 극대화한 기술입니다.)

---

## 7. 🔬 HTTP 덤프 분석 (Wireshark 실습)

Wireshark로 실제 HTTP 통신 패킷을 캡처하여 분석한 내용입니다. 

### 전체 흐름 (페이지 57)


* **패킷 7, 8, 9 (TCP 3-way Handshake)** 
    * `[SYN]` (클라이언트 → 서버)
    * `[SYN, ACK]` (서버 → 클라이언트)
    * `[ACK]` (클라이언트 → 서버)
    * (이 3단계를 거쳐 TCP 연결이 수립됩니다.)
* **패킷 10 (HTTP GET 요청)** 
    * 클라이언트(203.247.40.209)가 서버(203.247.40.230) 80번 포트로 **`GET /test/sample.html HTTP/1.1`** 요청을 보냅니다. 
* **패킷 11 (HTTP 200 OK 응답)** 
    * 서버가 **`HTTP/1.1 200 OK`** 응답과 함께 (text/html) 본문을 전송합니다. 
* **패킷 16 (HTTP GET 요청 - favicon)** 
    * 브라우저가 `sample.html`을 받은 후, 탭에 표시할 아이콘(`favicon.ico`)을 추가로 요청합니다. (영속적 연결이므로 TCP 재연결 없음)
* **패킷 17 (HTTP 200 OK 응답 - favicon)** 
    * 서버가 아이콘 파일로 응답합니다. 

### 요청 메시지 상세 분석 (페이지 58-65)

(패킷 10번 상세 내용) 
* **Request Line**: `GET /test/sample.html HTTP/1.1` 
    * `GET` 메소드 
    * `/test/sample.html` URI (경로) 
    * `HTTP/1.1` 버전 
* **Request Headers**
    * `Host: netwk.hannam.ac.kr`: 접속하려는 호스트 
    * `Connection: keep-alive`: 영속적 연결 사용 요청 (HTTP 1.1의 특징) 
    * `User-Agent: Mozilla/5.0 ... Chrome/79...`: 크롬 브라우저에서 요청함 
    * `Accept: text/html...`: HTML 문서를 받을 수 있음 
    * `Accept-Language: ko-KR...`: 한국어를 선호함 
    * `Cookie: ...`: 저장된 쿠키를 전송함 

HTTP 1.1은 1.0과 달리, `Connection` 헤더를 이용해 한 번의 연결로 여러 파일(HTML, 이미지 등)을 받아오고 캐시 확인 기능이 추가되어 고속 처리가 가능해졌습니다. 

### 응답 메시지 상세 분석 (페이지 66-71)

(패킷 11번 상세 내용) 
* **Status Line**: `HTTP/1.1 200 OK` 
    * `HTTP/1.1` 버전 
    * `200` 상태 코드 (정상) 
    * `OK` 상태 문구 
* **Response Headers**
    * `Date: ...`: 서버가 응답한 시간 
    * `Server: Apache`: 서버 소프트웨어는 Apache임 (이를 '배너 메시지'라고 부름) 
    * `Content-Length: 108`: 본문(HTML) 길이가 108바이트 
    * `Keep-Alive: timeout=5, max=100`: 영속적 연결 유지 (5초간 요청 없으면 종료) 
    * `Connection: Keep-Alive`: 영속적 연결 사용 중 
    * `Content-Type: text/html`: 본문 내용은 HTML 형식임 
* **Body** (본문) 
    * `Line-based text data` (108 바이트) 
    * 실제 HTML 소스 코드 (`<html><h1>homepage</h1></html>`) 
    * 브라우저는 이 HTML을 해석하여 화면에 "homepage"라는 큰 글자를 표시합니다. 

---

## 8. 🛠️ WWW & HTTP 실습

(페이지 72-86)
이론을 바탕으로 실제 네트워크 도구를 사용해 WWW와 HTTP를 확인하는 실습입니다.

### 실습 목표 

1.  `www`가 붙은 URL과 없는 URL의 차이 확인하기 
2.  `http://` (80 포트) vs `https://` (443 포트) 요청 차이 확인하기 
3.  HTTP 요청/응답 헤더 직접 살펴보기 

### 실습 1: `ping`으로 주소 비교 

* `ping example.com` → IP: `23.192.228.84` 
* `ping www.example.com` → IP: `23.65.188.18` (별칭: `a1422.dscr.akamai.net`) 
* **결과**: `example.com`과 `www.example.com`은 **서로 다른 IP 주소**를 가집니다. `www`가 붙은 주소는 Akamai (CDN 업체) 서버를 가리키고 있습니다. 

### 실습 2: `curl`로 헤더 확인 

* `curl -I http://example.com` → `HTTP/1.1 200 OK` 
* `curl -I http://www.example.com` → `HTTP/1.1 200 OK` 
* `curl -I https://www.example.com` → `HTTP/1.1 200 OK` 
* **결과**:
    * 세 주소 모두 `200 OK` (정상) 응답을 줍니다.
    * `Cache-Control: max-age=86000` 헤더: 24시간(86400초) 동안 캐시할 수 있음을 의미합니다. 
    * `Alt-Svc: h3=":443"` 헤더 (HTTPS 응답에만 있음) : "이 서버는 443 포트를 통해 더 빠른 **HTTP/3** 프로토콜도 지원한다"는 힌트입니다. 

### 실습 3: `nslookup` (DNS 조회) 

* `nslookup example.com` 
* **결과**: `example.com` 도메인 하나에 **수많은 IPv4, IPv6 주소**가 매핑되어 있습니다. 이것이 바로 CDN의 특징입니다. (사용자 위치에 따라 가장 가까운 서버 IP를 돌려줌) 

### 실습 4: `nmap` (포트 스캔) 

* `nmap -sV example.com` (서버의 열린 포트와 서비스 버전 확인) 
* **결과**: 
    * `80/tcp open http`: 80번(HTTP) 포트가 열려있음.
    * `443/tcp open ssl/http`: 443번(HTTPS) 포트가 열려있음.
    * **VERSION**: `AkamaiGHost (Akamai's HTTP ... service)`
    * **결론**: `nmap`을 통해 이 서버가 Akamai CDN의 전용 캐시 프록시 서버(`AkamaiGHost`)임을 명확히 확인했습니다. 

### 실습 5: `curl`로 다른 Content-Type 요청

* `curl -I https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png` (구글 로고 이미지 요청) 
* **결과**:
    * `HTTP/2 200` (HTTP/2 프로토콜로 성공) 
    * **`content-type: image/png`**: 응답 본문이 `png` 이미지 형식임을 알려줍니다. 
    * `content-length: 5969`: 이미지 크기는 5969 바이트입니다. 

---

이상으로 3주차 WWW & HTTP 강의 자료의 모든 내용을 풀어서 설명해 드렸습니다.
